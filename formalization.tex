\documentclass{article}
\usepackage{todonotes}
\usepackage{lscape}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bcprules}
\usepackage{mathpartir}
\usepackage{mdframed}

%% Math
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{thm}{Theorem}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{defn}{Definition}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{prop}{Property}[section]

%% Spacing
\newcommand{\gap}{\quad\quad}

%% Arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

%% Syntax
% Member sequences
\newcommand{\seq}[1]{\overline{#1}}

%% Operational model
\newcommand{\Req}[3]{\text{Req}_s(#1, #2, #3)}
\newcommand{\Res}[3]{\text{Res}_s(#1, #2, #3)}
\newcommand{\ReqF}[2]{\text{Req}_{\iota}(#1, #2)}
\newcommand{\ReqE}[3]{\text{Req}_f(#1, #2, #3)}
\newcommand{\Per}[3]{\text{Persist}(#1, #2, #3)}

%% Calculus abbreviations
\newcommand{\None}{\text{None}}
\newcommand{\Some}[1]{\text{Some}(#1)}

\newcommand{\Val}[1]{\text{Val}(#1)}
\newcommand{\Fwd}[1]{\text{Fwd}(#1)}

%% Util
\newcommand{\consume}[3]{\text{consume}(#1, #2, #3)}

%% Misc
\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

\begin{document}

\todo[inline]{Conclude Part 2 and 3 of Subject Reduction}
\todo[inline]{Fix fault tolerance}
\todo[inline]{Related work}
\todo[inline]{Verbalize formalization}
\todo[inline]{Fix memory handling\\[2ex] IDEA: provide explicit operators for memory handling; a subsequent static analysis would augment those explicit declaration with further usage of those explicit operators; i.e., a static analysis yields a composition of those memory handling primitives\\[2ex] First approach: incorporate reference counting}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                       & \mbox{{\it{terms:}}} \\                                
\gap \:\:\:\:  x                                                            & \mbox{variable} \\                                
\gap ~|~  (x: T) \Rightarrow t                                              & \mbox{abstraction} \\                                
\gap ~|~  t~t                                                               & \mbox{application} \\                                
%\gap ~|~  \texttt{let}~x = t~\texttt{in}~t                                  & \mbox{let binding} \\                                
\gap ~|~  \{ \seq{l = t} \}                                                 & \mbox{record construction} \\                                
\gap ~|~  t.l                                                               & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}       & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(t)                                                 & \mbox{spawn host} \\
\gap ~|~  \texttt{populate}(t, t)                                           & \mbox{populate silo} \\
\gap ~|~  \texttt{map}(t, t)                                                & \mbox{map} \\                          
\gap ~|~  \texttt{flatMap}(t, t)                                            & \mbox{flatMap} \\                          
\gap ~|~  \texttt{persist}(t)                                               & \mbox{persist} \\
\gap ~|~  \texttt{send}(t)                                                  & \mbox{send} \\           % send  :: Ref a -> Fut a
\gap ~|~  \texttt{await}(t)                                                 & \mbox{await future} \\   % await :: Fut a -> a                        
\gap ~|~  \iota                                                             & \mbox{location} \\                          
\gap ~|~  r                                                                 & \mbox{silo reference} \\                          
                                                                            & \\                                
v ::=                                                                       & \mbox{{\it{values:}}} \\                                
\gap \:\:\:\: (x: T) \Rightarrow t                                          & \mbox{abstraction value} \\                                
\gap ~|~  \{ \seq{l = v} \}                                                 & \mbox{record value} \\                                
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}                                                                 & \mbox{spore value} \\                                
\gap ~|~  \iota                                                             & \mbox{location} \\
\gap ~|~  r                                                                 & \mbox{silo reference} \\
                                                                            & \\   
T ::=                                                                       & \mbox{{\it{types:}}} \\                          
\gap \:\:\:\: T \Rightarrow T                                               & \mbox{abstraction type} \\                          
\gap ~|~  \{ \seq{l : T} \}                                                 & \mbox{record type} \\                          
\gap ~|~  \mathcal{S}                                                       & \mbox{} \\
\gap ~|~  \texttt{Host}                                                     & \mbox{host type} \\
\gap ~|~  \texttt{SiloRef}[T]                                               & \mbox{silo reference type} \\
\gap ~|~  \texttt{Future}[T]                                                & \mbox{future type} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}                    & \mbox{abstract spore type} \\
\ea$

\caption{Abstract syntax of core language.}
\end{figure}

Classification of $r$ and $\iota$ is specified at Figure~\ref{fig:elems-opsem}.

$\iota$ .... decentralized identifier

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Elements of the operational model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
r ::=                                                  & \mbox{{\it{silo reference values:}}} \\
\gap \:\:\:\: \text{Mat}(\omega)                       & \mbox{materialized} \\    
\gap ~|~  \text{Mapped}(\omega, r, p)                  & \mbox{lineage with \texttt{map}} \\    
\gap ~|~  \text{FMapped}(\omega, r, p)                 & \mbox{lineage with \texttt{flatMap}} \\   
\gap ~|~  \text{Persist}(\omega, r)                    & \mbox{lineage with \texttt{persist}} \\
                                                       & \\   
\omega  ::= (h,i) \quad \text{where}~i \in \mathbb{N}  & \mbox{decentralized identifier} \\
                                                       & \\
Q      ::=                                             & \mbox{{\it{message queue values:}}} \\
\gap \:\:\:\: \epsilon                                 & \mbox{empty queue} \\
\gap ~|~    {\Res \omega v P} :: Q                     & \mbox{response (silo)} \\
\gap ~|~    {\Req h r \omega} :: Q                     & \mbox{request (silo)}  \\
\gap ~|~    {\ReqF \iota \omega} :: Q                  & \mbox{request (future)}  \\
\gap ~|~    {\ReqE h r \omega} :: Q                    & \mbox{request (fault)} \\
\ea$

\caption{Elements of the operational model.}
\label{fig:elems-opsem}

\end{figure}

\begin{description}
\item[$\iota$] Encodes latency, in terms of completion of a materialization of a silo, as well as the location of the either already materialized or to be materialized silo. The location, in turn, serves as the unique, decentralized identifier of the respective silo reference.

% << Network communication >>
%
%               <<CODE>>                                                    << LINEAGE>>                             <<SILO>>
% Host: h0    
% val r0: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))                   ~~>        h1 
% r0.id    == (h1,0)                                                              ^
% host(r0) == h1                                                                  |
%                                                                                 |
% << No network communication >>                                                  |
%                                                                                 |
% val r1: SiloRef[List[Vehicle]] = r0 map sp0                           ~~>   Mapped((h0,0), r0, sp0, None) ~~>        h1
% r1.id    == (h0,0)      
% host(r1) == h1      
%   
% << Network communication >>   
%   
% val r2: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))
% r2.id    == (h1,0)
% host(r2) == h1 
% r2       == r0

\item[$Mat(\iota)$] A silo reference where the referenced silo is already materialized, or is to be materialized, at location $\iota$.
% (h,i) is the decentralized identifier of the materialized silo hosted at h. In this case \iota gives us the location of the materialized silo.

\item[$Mapped(\iota, r, p)$] Map spore $p$ over the silo which is referenced by $r$. The resulting silo of this transformation is referenced by the new silo reference identified by $\iota$. 

%      r     --> s  @ host(r)
%                ^
%                |
%                | Mapped
%                |
%      r'    --> s' @ host(r) = host(r')
%
% Decentralized identifier of r' is \iota.

\item[$FMapped(\iota, r, p)$] Analogous to $Mapped$.
\end{description}

A lineage build up by those silo reference values can be considered as a {\emph{data flow graph}}\cite{???}. %Note, verbalisation is imperative to emphasize lazy creation. 

\begin{description}
\item[${\Res \iota v P}$] A response message which instructs the receiver to complete future $\iota$ with value $v$. % TODO: explain `P`.

\item[${\Req h r \iota}$] A request message from $h$ which instructs the receiver to respond with the materialized silo referenced by $r$; $\iota$ uniquely identifies the response in terms of the future $\iota$ to be completed by the sender of the request.

\item[$ReqF(h, r, \iota)$] Analogous to $Req$.
\end{description}

In the following we introduce a function to backtrack the host of a referenced silo.

\begin{defn}[Host]
  The function application $host(r)$ obtains the host of the silo referenced by $r$; $host$ is defined as follows:
  
  $host(r) := \begin{cases}
    h        & \text{if } r = Mat((h, i)) \\
    host(r') & \text{if } r = Mapped(\_, r', \_) \\
    host(r') & \text{if } r = FMapped(\_, r', \_) \\
    host(r') & \text{if } r = Persist(\_, r', \_) \\
    \end{cases}$
\end{defn}

Analogous to~\cite{TAPL}, we introduce the notion of an evaluation context and write $E[t]$ for the ordinary term obtained by replacing the hole in $E$ with $t$. Evaluation contexts capture the notion of the ``next subterm to be reduced.''

\begin{defn}[Evaluation Context]
  The set of evaluation contexts is defined as follows:
  
 $\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
%\gap ~|~  \texttt{let}~x = E~\texttt{in}~t                                                                & \mbox{let (bind)} \\
%\gap ~|~  \texttt{let}~x = v~\texttt{in}~E                                                                & \mbox{let (body)} \\
\gap ~|~  \{ \seq{l = v} ; l_i = E ; \seq{l' = t} \}                                                      & \mbox{record} \\
\gap ~|~  E.l                                                                                             & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(E)                                                                               & \mbox{spawn} \\
\gap ~|~  \texttt{populate}(E, t)                                                                         & \mbox{populate (host)} \\
\gap ~|~  \texttt{populate}(v, E)                                                                         & \mbox{populate (spore)} \\
\gap ~|~  \texttt{map}(E, t)                                                                              & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E)                                                                              & \mbox{map (fun)} \\
\gap ~|~  \texttt{flatMap}(E, t)                                                                          & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E)                                                                          & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{persist}(E)                                                                             & \mbox{persist} \\
\gap ~|~  \texttt{send}(E)                                                                                & \mbox{send} \\
\gap ~|~  \texttt{await}(E)                                                                               & \mbox{await} \\
\ea$ 
\end{defn}

\begin{defn}[Silo reference identifier]
    $id(r) := \begin{cases}
    \omega  & \text{if } r = Mat(\omega) \\
    \omega  & \text{if } r = Mapped(\omega, r', \_) \\
    \omega  & \text{if } r = FMapped(\omega, r', \_) \\
    \omega  & \text{if } r = Persist(\omega, r', \_) \\
    \end{cases}$
\end{defn}

\begin{defn}[Silo reference parent]
    $parent(r) := \begin{cases}
    \None     & \text{if } r = Mat(\_) \\
    \Some{r'} & \text{if } r = Mapped(\_, r', \_) \\
    \Some{r'} & \text{if } r = FMapped(\_, r', \_) \\
    \Some{r'} & \text{if } r = Persist(\_, r', \_) \\
    \end{cases}$
\end{defn}

\begin{defn}[Consume silo]
Consume silo $\omega$ with persist set $P$ in silo store $S$ \\
  $consume(\omega, P, S) := \begin{cases}
  S - \omega & \text{if } P = \emptyset \\
  S          & \text{otherwise} \\
  \end{cases}$
\end{defn}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Lambda reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-AppAbs}] {} {
  E[((x: T) \Rightarrow t)~v']~|~\mu
  \rightarrow^h
  E[[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-ProjRcd}] {} {
  E[\{\seq{l_i = v_i^{i \in 1..n}}\}.l_j]~|~\mu
  \rightarrow^h
  E[v_j]~|~\mu
}

\inferrule[\textsc{R-AppSpore}] {} {
  E[(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~v']~|~\mu
  \rightarrow^h
  E[\seq{[x \mapsto v]}[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-Await}] {
  \mu(\iota) = \text{Some}(v)
} {
  E[\texttt{await}(\iota)]~|~\mu
  \rightarrow^h
  E[v]~|~\mu
}

\inferrule[\textsc{R-Map}] {
  r' = \text{Mapped}((h, i), r, p) \quad
  i~\text{fresh}
} { 
  E[\texttt{map}(r, p)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\inferrule[\textsc{R-FMap}] { 
  r' = \text{FMapped}((h, i), r, p) \quad
  i~\text{fresh}
} {
  E[\texttt{flatMap}(r, p)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\inferrule[\textsc{R-Persist}] { 
  r' = \text{Persist}((h, i), r, \cdot \cup \cdot) \quad
  i~\text{fresh}
} {
  E[\texttt{persist}(r)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\inferrule[\textsc{R-Unpersist}] { 
  r' = \text{Persist}((h, i), r, \cdot \setminus \cdot) \quad
  i~\text{fresh}
} {
  E[\texttt{unpersist}(r)]~|~\mu
  \rightarrow^h
  E[r']~|~\mu'
}

\end{mathpar}
\caption{Sequential reduction.}
\end{figure}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define silo store

We write $S' = S + (\iota \mapsto (B, P))$ to express the fact that $S'$ maps $\iota$ to a pair $(B, P)$ and otherwise agrees with $S$. $B$ is a binding of the form $\Val{v}$ or $\Fwd{r}$; the former contains a materialized value $v$, the latter forwards to silo reference $r$, such that $\iota$ is effectively bound to the same value as the identifier of $r$. $P \subset Hosts$ is a set of hosts which have persisted the silo identified by $\iota$. We write $S(\iota) = \text{Some}(B, P)$ to express the fact that $S$ maps $\iota$ to $(B, P)$. We write $S(\iota) = \text{None}$ if $S$ does not have a mapping for $\iota$.

Our formalization simplifies the computation model with respect to materialized silos. In case of a silo reference of the form $Mat((h, i))$ we assume that there is a mapping in the corresponding silo store $S$, such that $S((h, i)) = \text{Some}(\Val{v}, \{ h \})$ for some value $v$.

%% r = Mat((h,i)) = init(hdfs://...)
%% r.unpersist

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-Seq}] { 
  E[t]~|~\mu \rightarrow^h E[t']~|~\mu'
} {
  (E[t], \mu, Q, S)^h
  \longrightarrow
  (E[t'], \mu', Q, S)^h
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\inferrule[\textsc{R-Send1Local}] {
  host(r) = h                               \quad
  S(id(r)) = (\Val{v}, P)                   \\
  \iota~\text{fresh}                       \quad
  \mu' = [\iota \mapsto \text{Some}(v)]\mu
} {
  (E[\texttt{send}(r)], \mu, Q, S)^h
  \longrightarrow
  (E[\iota], \mu', Q, S)^h
}

\inferrule[\textsc{R-Send2Local}] {
  host(r)    = h                         \quad
  id(r) \notin dom(S)                    \\
  \iota~\text{fresh}                    \quad
  \mu' = [\iota \mapsto \text{None}]\mu
} {
  (E[\texttt{send}(r)], \mu, Q, S)^h
  \longrightarrow
  (E[\iota], \mu', Q \cdot {\Req h r {id(r)}} \cdot {\ReqF {\iota} {id(r)}}, S)^h
}

\inferrule[\textsc{R-ReqF1}] {
  Q         = {\ReqF \iota \omega} :: Q' \quad
  S(\omega) = (\Val{v}, P)               \\
  S'        = {\consume \omega P S}      \quad
  \mu'      = [\iota \mapsto \text{Some}(v)]\mu
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu', Q', S')^h
}

\inferrule[\textsc{R-ReqF2}] {
  Q           = {\ReqF \iota \omega} :: Q'    \quad
  \omega \notin dom(S)
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu, Q' \cdot {\ReqF \iota \omega}, S)^h
}

\end{mathpar}
\caption{Deterministic reduction (future).}
\end{figure}

% Note: design approach is to *not* replace Fwds in the silo store, since
% it would require copying data. Instead, we leverage the flexibility of
% Req messages to correctly forward requests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Important that Res message contains correct P, since R-Res
% updates silo store.
% Goal: theorem which states that persist sets are "correct".
% We don't lose hosts from persist sets.

\begin{figure}[ht!]
\centering

\begin{mathpar}

\inferrule[\textsc{R-Res}] {
  Q  = {\Res \omega v P} :: Q'          \\
  S' = [\omega \mapsto (\Val{v}, P)]S
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q', S')^h
}

\inferrule[\textsc{R-Req1Local}] {
  Q         = {\Req h r \omega} :: Q'        \quad %
  S(id(r))  = (\Fwd{r'}, P)                  \quad %
  S(id(r')) = (\Val{v}, P')                  \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v P}, S)^h
}

\inferrule[\textsc{R-Req2Local}] {
  Q         = {\Req h r \omega} :: Q'              \quad %
  S(id(r))  = (\Fwd{r'}, P)                        \quad %
  id(r') \notin dom(S)                             \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} \omega}, S)^h
}

\inferrule[\textsc{R-ReqMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'               \quad %
  r          = \text{Mapped}(\omega', r', p)            \quad %
  S(id(r'))  = (\Val{v}, P)                             \\
  v'         = p(v)                                          \quad %
  S'         = [\omega' \mapsto (\Val{v'}, \emptyset)]S      \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} r \omega}, S'')^h
}

\inferrule[\textsc{R-ReqFMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'      \quad %
  r          = \text{FMapped}(\omega', r', p)  \quad %
  S(id(r'))  = (\Val{v}, P)                    \\
  r''        = p(v)                                        \quad %
  S'         = [\omega' \mapsto (\Fwd{r''}, \emptyset)]S   \quad
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} {r''} \omega}, S'')^h
}

\inferrule[\textsc{R-ReqPersistLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'                      \quad %
  r          = {\Per {\omega'} {r'} \star}                  \quad %
  \omega'    = (h'', i)                                      \quad %
  S(id(r'))  = (\Val{v}, P)                               \\
  P'         = P \star \{h''\}                               \quad %
  S'         = [\omega' \mapsto (\Val{v}, P')]S            \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q,  S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v {P'}}, S'')^h
}

\inferrule[\textsc{R-ReqParentLocal}] {
  Q               = {\Req {h'} r \omega} :: Q'  \quad %
  \text{Some}(r') = parent(r)                  \quad %
  id(r') \notin dom(S)                          \\
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} {id(r')}} \cdot {\Req {h'} r \omega}, S)^h
}

\end{mathpar}
\caption{Deterministic reduction (silo).}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Map}] ...

\item[\textsc{R-FMap}] ...

\item[\textsc{R-Await}] ...

\item[\textsc{R-Res}] ...

\item[\textsc{R-ReqLocal}] ...
\end{description}

Note, the reduction rules \textsc{R-Map} and \textsc{R-FMap} do not involve communication with other hosts.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Non-deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% (t, Q, S)^h_c -> <crash>
% H' = { h' | h \in H \land h' = crashed(h_c, h) }
% --------------------------------------------------
%    { (t, Q, S)^h_c } \cup H -->> H'
%
%
% update silo store to reflect crash of h_c
% S' = { id -> (v, C') | id -> (v, C) \in S \land C' = C[h_c -> 0] }
% ---------------------------------------------------------------------
%    crashed(h_c, (t, Q, S)^h) = (t, Q, S')^h
%
%
%   S(id) =  Some(v)       |  None
%
%   S(id) = (Some(v), cnt) | (None, cnt)
%
%   S(id) = (Some(v), [h -> 3, h' -> 2]) | (None, ...)
%
%   S(id) = (Some(v), C)   | (None, C)


\begin{figure}[ht!]
\begin{mathpar}
\inferrule[\textsc{R-Determ}] {
  (t, \mu, Q, S)^h \rightarrow (t', \mu', Q', S')^h
} { 
  \{ (t, \mu, Q, S)^h \} \cup H
  \twoheadrightarrow
  \{ (t', \mu', Q', S')^h \} \cup H
}

\inferrule[\textsc{R-Spawn}] { 
  h'~\text{fresh}    \quad
  \iota~\text{fresh} \quad
  \mu' = [\iota \mapsto h']\mu
} {
  \{ (E[\texttt{spawn}(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})], \mu, Q, S)^h \} \cup H
  \\ \twoheadrightarrow
  \{ (E[\iota], \mu', Q, S)^h, ((\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~\{\}, \epsilon, \epsilon, \epsilon)^{h'} \} \cup H
}

% TODO send spore instead of a value `v`
\inferrule[\textsc{R-Populate}] { 
  \mu(\iota) = h'                                         \quad
  S''        = [\omega \mapsto ({\Val v}, \emptyset)]S'   \quad
  \omega     = (h', i)                                    \quad
  i~\text{fresh}
} {
  \{ (E[\texttt{populate}(\iota, v)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\text{Mat}(\omega)], \mu, Q, S)^h, (t', \mu', Q', S'')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req1}] {
  Q        = {\Req {h'} r \omega} :: Q''  \quad
  S(id(r)) = (\Val{v}, P)                 \quad
  m        = {\Res \omega v P}
} {
  \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

% Rules that send Req:
% R-Send: true (append)
% (R-Req2Map: true (prepend))
% R-Req2Fwd: true (prepend)
% 
% if a rule sends Req(h, r) to h', is it true that host(r) == h'?
% XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\inferrule[\textsc{R-Req2}] {
  Q         = {\Req {h'} r \omega} :: Q''           \quad %
  S(id(r))  = (\Fwd{r'}, P)             \\ %
  S(id(r')) = (\Val{v}, P')             \quad %
  m         = {\Res \omega v P}
} {
  \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

% 1. Angenommen Host h hat einen \Fwd{r'}, dann wissen wir nicht, 
%    auf welchem Host r' liegt. Das war der eigentliche Grund, Fwd
%    einzufuehren, weil dann ein flatMap keine Daten transferieren muss.
%    D.h. wir wollen zulassen, dass eine Referenz in einem Fwd auf
%    einem beliebigen Host liegen kann.
% Jetzt kann es sein, dass ich auf Host h ein r = r0.flatMap(p) mache.
% diese Referenz r kann ich an einen anderen Host h' geben.
% Jetzt macht Host h' ein r.send(). D.h., h' schickt einen Req(h', r) an h.
% Jetzt sagt Host h: S(id(r)) = Fwd(r'), und r' kann auch auf Host h' sein
% (da Host von r' beliebig wie oben erwaehnt).
% Und in diesem Fall gilt, dass host(r') = h' ist, und daher Host h
% einen Req(h', r' r) an h'' = h' sendet. Das hat zur Folge, das Host h'
% jetzt einen Req(h', r', r) bearbeiten muss. Daher muessen auch die lokalen
% Regeln mit zwei unterschiedlichen Referenzen umgehen koennen, weil
% r definitiv ungleich r' ist.
\inferrule[\textsc{R-Req3}] {
  Q         = {\Req {h''} r \omega} :: Q''           \quad %
  S(id(r))  = (\Fwd{r'}, P)                          \\ %
  id(r') \notin dom(S)                               \quad %
  h'        = host(r')                               \quad %
  m         = {\Req {h''} {r'} \omega}
} {
  \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

\inferrule[\textsc{R-Send}] {
  host(r) = h'                          \quad
  h' \neq h                             \quad
  m = {\Req h r {id(r)}}                \quad
  \iota~\text{fresh}                    \quad
  \mu'' = [\iota \mapsto \text{None}]\mu
} {
  \{ (E[\texttt{send}(r)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\iota], \mu'', Q, S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

\end{mathpar}
\caption{Non-deterministic reduction.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Send}] ...

\item[\textsc{R-Req1}] ...

\item[\textsc{R-Req2}] ...

\item[\textsc{R-Req3}] ...

\item[\textsc{R-Req4}] ...
\end{description}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Type assignment.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}

\inferrule[\textsc{S-Record}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(\{ \seq{l : T} \})
}

\inferrule[\textsc{S-Spore}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
}

\inferrule[\textsc{S-SiloRef}] {} {
  serializable(\texttt{SiloRef}[T])
}

\end{mathpar}
\caption{Serializable types.}
\end{figure}


\begin{figure}[ht!]
\begin{mathpar}
% variable
\inferrule[\textsc{T-Var}] {
  x : T \in \Gamma
} { 
  \Gamma ; \Sigma ; \Delta \vdash x : T
}

\inferrule[\textsc{T-Loc}] {
  \Sigma(\iota) : T
} {
  \Gamma ; \Sigma ; \Delta \vdash \iota : T
}

% abstraction
\inferrule[\textsc{T-Abs}] {
  \Gamma, x : T ; \Sigma ; \Delta \vdash t : T'
} {
  \Gamma ; \Sigma ; \Delta \vdash ((x: T) \Rightarrow t) : T \Rightarrow T'
}

% application
\inferrule[\textsc{T-App}] {
  \Gamma ; \Sigma ; \Delta \vdash t : T \Rightarrow T' \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : T
} { 
  \Gamma ; \Sigma ; \Delta \vdash (t~t') : T'
}

% record
\inferrule[\textsc{T-Record}] {
  \Gamma ; \Sigma ; \Delta \vdash \seq{t} : \seq{T}
} {
  \Gamma ; \Sigma ; \Delta \vdash \{ \seq{l = t} \} : \{ \seq{l : T} \}
}

% selection
\inferrule[\textsc{T-Select}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \{ \seq{l : T} \}
} {
  \Gamma ; \Sigma ; \Delta \vdash t.l_i : T_i
}

% spore
\inferrule[\textsc{T-Spore}] {
  \Gamma ; \Sigma ; \Delta \vdash \seq{t} : \seq{T}  \quad
  \seq{x : T}, x : T ; \emptyset ; \Delta \vdash t : T' \quad
  \forall T_i \in \seq{T}.~serializable(T_i)
} { 
  \Gamma ; \Sigma ; \Delta \vdash (\texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}) : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}
}

\inferrule[\textsc{T-AppSpore}] {
  \Gamma ; \Sigma ; \Delta \vdash t : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\} \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : T
} { 
  \Gamma ; \Sigma ; \Delta \vdash (t~t') : T'
}

% spawn
\inferrule[\textsc{T-Spawn}] {
  \Gamma ; \Sigma ; \Delta \vdash t : (\{\} \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{spawn}(t) : \texttt{Host}
}

% populate
% TODO make async (Future[SiloRef[T]]); cf. R-Populate
\inferrule[\textsc{T-Populate}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{Host} \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : T            \quad
  serializable(T)
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{populate}(t, t') : \texttt{SiloRef}[T]
}

% map
\inferrule[\textsc{T-Map}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : (T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{map}(t, t') : \texttt{SiloRef}[T']
}

% flatMap
\inferrule[\textsc{T-FMap}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma ; \Delta \vdash t' : (T \Rightarrow \texttt{SiloRef}[T']~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{flatMap}(t, t') : \texttt{SiloRef}[T']
}

% persist
\inferrule[\textsc{T-Persist}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{persist}(t) : \texttt{SiloRef}[T]
}

% send
\inferrule[\textsc{T-Send}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{send}(t) : \texttt{Future}[T]
}

\inferrule[\textsc{T-SiloRef}] {
  \Delta(id(r)) = T \quad
  \Delta \vdash r
} {
  \Gamma ; \Sigma ; \Delta \vdash r : \texttt{SiloRef}[T]
}

% await
\inferrule[\textsc{T-Await}] {
  \Gamma ; \Sigma ; \Delta \vdash t : \texttt{Future}[T]
} {
  \Gamma ; \Sigma ; \Delta \vdash \texttt{await}(t) : T
}

\end{mathpar}
\caption{Type assignment.}
\end{figure}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Subject reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}

\inferrule[\textsc{WF-Store1}] {} {
  \emptyset \vdash \emptyset
}

\inferrule[\textsc{WF-Store2}] {
  \Sigma \vdash \mu
} {
  [\iota \mapsto T]\Sigma \vdash [\iota \mapsto v]\mu
}

\inferrule[\textsc{WF-Ref1}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma ; \Delta \vdash p : T' \Rightarrow T~\{\ldots\} \quad
  \Delta \vdash r
} {
  \Delta \vdash \text{Mapped}(\omega, r, p)
}

\inferrule[\textsc{WF-Ref2}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma ; \Delta \vdash p : T' \Rightarrow \texttt{SiloRef}[T]~\{\ldots\} \quad
  \Delta \vdash r
} {
  \Delta \vdash \text{FMapped}(\omega, r, p)
}

\inferrule[\textsc{WF-Ref3}] {
  \Delta(\omega) = T  \quad
  \Delta(id(r)) = T   \quad
  \Delta \vdash r
} {
  \Delta \vdash {\Per \omega r {\star}}
}

\inferrule[\textsc{WF-Ref4}] {
  \omega \in dom(\Delta)
} {
  \Delta \vdash {\text{Mat}(\omega)}
}

\inferrule[\textsc{WF-SiloStore1}] {} {
  \Delta \vdash \emptyset
}

\inferrule[\textsc{WF-SiloStore2}] {
  \Delta(\omega) = T                  \quad
  \emptyset ; \emptyset ; \Delta \vdash v : T  \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto ({\Val v}, P)]S
}

\inferrule[\textsc{WF-SiloStore3}] {
  \Delta(id(r)) = \Delta(\omega)      \quad
  \Delta \vdash r                     \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto ({\Fwd r}, P)]S
}

\inferrule[\textsc{WF-Q1}] {} {
  \Delta ; \Sigma \vdash \epsilon
}

\inferrule[\textsc{WF-Q2}] {
  \Delta(\omega) = T                  \quad
  \Sigma(\iota)  = \texttt{Future}[T] \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\ReqF \iota \omega} :: Q
}

\inferrule[\textsc{WF-Q3}] {
  \Delta(\omega) = T                  \quad
  \emptyset ; \emptyset ; \Delta \vdash v : T  \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\Res \omega v P} :: Q
}

\inferrule[\textsc{WF-Q4}] {
  \Delta(id(r)) = \Delta(\omega) \quad
  \Delta \vdash r \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\Req h r \omega} :: Q
}

\inferrule[\textsc{WF-HostConfig}] {
  \Sigma \vdash \mu              \quad
  \Delta \vdash S                \quad
  \Delta ; \Sigma \vdash Q       \quad
  \Gamma ; \Sigma ; \Delta \vdash t : T
} {
  \Delta ; \Sigma \vdash (t, \mu, Q, S)^h
}

\inferrule[\textsc{WF-Host1}] {} { 
  \Delta \vdash \emptyset
}

\inferrule[\textsc{WF-Host2}] {
  \exists \Sigma.~\Delta ; \Sigma \vdash (t, \mu, Q, S)^h  \quad
  \Delta \vdash H
} {
  \Delta \vdash \{ (t, \mu, Q, S)^h \} \cup H
}

\end{mathpar}
\caption{Well-formedness.}
\end{figure}

\begin{thm}
\emph{(Substitution Lemma)}\label{th:subst}
If $\Gamma , x : T' ; \Sigma ; \Delta \vdash t : T$ and $\Gamma ; \Sigma ; \Delta \vdash v : T'$ then $\Gamma ; \Sigma ; \Delta \vdash [x \mapsto v]t : T$.
\end{thm}
\begin{proof}
By induction on the derivation of $\Gamma , x : T' ; \Sigma ; \Delta \vdash t : T$.
\end{proof}

\begin{thm}
\emph{(Queue Concat)}\label{lem:queue-concat}
If $\Delta ; \Sigma \vdash Q$ and $\Delta ; \Sigma \vdash Q'$ then $\Delta ; \Sigma \vdash Q ::: Q'$.
\end{thm}
\begin{proof}
By induction on the length of $Q$. The case where $Q = \epsilon$ is trivial.

Case $Q = m :: Q''$.
\begin{enumerate}
\item[A1.] By WF-Q1-4, $\Delta ; \Sigma \vdash Q''$.
\item[A2.] By the IH, $\Delta ; \Sigma \vdash Q'' ::: Q'$.
\end{enumerate}

\begin{itemize}
\item Case $m = {\ReqF \iota \omega}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(\omega) = T$
  \item $\Sigma(\iota) = \texttt{Future}[T]$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 2.
\item By A2., 1.a-b), and WF-Q2, $\Delta ; \Sigma \vdash m :: Q'' ::: Q'$.
\end{enumerate}

\item Case $m = {\Res \omega v P}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q3
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(\omega) = T$
  \item $\emptyset ; \emptyset \vdash v : T$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 2.
\item By A2., 1.a-b), and WF-Q3, $\Delta ; \Sigma \vdash m :: Q'' ::: Q'$.
\end{enumerate}

\item Case $m = {\Req h r \omega}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \Delta(\omega)$
  \item $\Delta ; \Sigma \vdash Q''$
  \item $\Delta \vdash r$
  \end{enumerate}
% 2.
\item By A2., 1.a,c), and WF-Q4, $\Delta ; \Sigma \vdash m :: Q'' ::: Q'$.
\end{enumerate}
\end{itemize}
\end{proof}

\begin{thm}
\emph{(Queue Ordering)}\label{lem:queue-ordering}
If $\Delta ; \Sigma \vdash m :: Q$ then $\Delta ; \Sigma \vdash Q \cdot m$.
\end{thm}
\begin{proof}
By the assumption and WF-Q1-4, $\Delta ; \Sigma \vdash m :: \epsilon$ and $\Delta ; \Sigma \vdash Q$. By Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma \vdash Q ::: (m :: \epsilon)$.
\end{proof}

\begin{thm}
\emph{(Serializable Values)}\label{lem:ser-values}
If $\Gamma ; \Sigma ; \Delta \vdash v : T$ and $serializable(T)$ then $\emptyset ; \emptyset ; \Delta \vdash v : T$.
\end{thm}
\begin{proof}
By induction on a derivation of $\Gamma ; \Sigma ; \Delta \vdash v : T$ with a case analysis on the last applied rule.

\begin{itemize}
\item Case T-SiloRef follows trivially.

\item Case T-Record.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma ; \Delta \vdash v : T$
  \item $serializable(T)$
  \end{enumerate}
% 2.
\item By T-Record
  \begin{enumerate}[label=(\alph*)]
  \item $v = \{\seq{l = v}\}$
  \item $T = \{\seq{l : T}\}$
  \item $\Gamma ; \Sigma ; \Delta \vdash \seq{v} : \seq{T}$
  \end{enumerate}
% 3.
\item By 2.b) and S-Record, $\forall T_i \in \seq{T}.~serializable(T_i)$.
% 4.
\item By 2.c), 3., and the IH, $\emptyset ; \emptyset ; \Delta \vdash \seq{v} : \seq{T}$.
% 5.
\item By 4. and T-Record, $\emptyset ; \emptyset ; \Delta \vdash \{\seq{l = v}\} : \{\seq{l : T}\}$.
\end{enumerate}

\item Case T-Spore is analogous to case T-Record.
\end{itemize}
\end{proof}

\begin{thm}
\emph{(Subject Reduction)}\label{th:pres}

\begin{enumerate}

\item If $\Gamma ; \Sigma ; \Delta \vdash t : T$, $\Sigma \vdash \mu$, and $t~|~\mu \rightarrow^h t'~|~\mu'$ then $\Gamma ; \Sigma' ; \Delta' \vdash t' : T$, and $\Sigma' \vdash \mu'$ for some $\Sigma' \supseteq \Sigma$ and $\Delta' \supseteq \Delta$.

\item If $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$ and $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$ then $\Delta' ; \Sigma' \vdash (t', \mu', Q', S')^h$ for some $\Delta' \supseteq \Delta$ and $\Sigma' \supseteq \Sigma$.

\item If $\Delta \vdash H$ and $H \twoheadrightarrow H'$ then $\Delta' \vdash H'$ for some $\Delta' \supseteq \Delta$.

\end{enumerate}

\end{thm}
\begin{proof}

Part 1: by induction on a derivation of $t~|~\mu \rightarrow^h t'~|~\mu'$ with case analysis of the last applied rule.

\begin{itemize}
\item Case R-AppAbs.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma ; \Delta \vdash t : T$
  \item $\Sigma \vdash \mu$
  \item $t~|~\mu \rightarrow^h t'~|~\mu'$
  \end{enumerate}
% 2.
\item By R-AppAbs
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[((x : T') \Rightarrow t'')~v']$
  \item $t' = E[[x \mapsto v']t'']$
  \item $\mu' = \mu$
  \end{enumerate}
% 3.
\item By 1.a) and 2.a), $\Gamma ; \Sigma ; \Delta \vdash ((x : T') \Rightarrow t'')~v' : T''$.
% 4.
\item By 3. and T-App,
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma ; \Delta \vdash ((x : T') \Rightarrow t'') : T' \Rightarrow T''$
  \item $\Gamma ; \Sigma ; \Delta \vdash v' : T'$
  \end{enumerate}
% 5.
\item By 4.a) and T-Abs, $\Gamma , x : T' ; \Sigma ; \Delta \vdash t'' : T''$.
% 6.
\item By 4.b), 5., and Lemma~\ref{th:subst}, $\Gamma ; \Sigma ; \Delta \vdash [x \mapsto v']t'' : T''$.
% 7.
\item By 1.a), 2.a-b), 3., and 6., $\Gamma ; \Sigma ; \Delta \vdash t' : T$.
% 8.
\item 2.c) and 7. close this case.
\end{enumerate}

\item Cases R-ProjRcd, R-AppSpore, and R-Await follow analogously.

\item Case R-Map.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma ; \Delta \vdash t : T$
  \item $\Sigma \vdash \mu$
  \item $t~|~\mu \rightarrow^h t'~|~\mu'$
  \end{enumerate}
% 2.
\item By R-Map
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{map}(r, p)]$
  \item $t' = E[r']$
  \item $r' = \text{Mapped}((h, i), r, p)$
  \item $i~\text{fresh}$
  \item $\mu' = \mu$
  \end{enumerate}
% 3.
\item By 1.a) and 2.a), $\Gamma ; \Sigma ; \Delta \vdash \texttt{map}(r, p) : \hat{T}$.
% 4.
\item By 3. and T-Map,
  \begin{enumerate}[label=(\alph*)]
  \item $\hat{T} = \texttt{SiloRef}[T']$
  \item $\Gamma ; \Sigma ; \Delta \vdash r : \texttt{SiloRef}[T'']$
  \item $\Gamma ; \Sigma ; \Delta \vdash p : (T'' \Rightarrow T' \{~\texttt{type}~\mathcal{C} = \seq{T}~\})$
  \end{enumerate}
% 5.
\item By 4.b) and T-SiloRef
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = T''$
  \item $\Delta \vdash r$
  \end{enumerate}
% 6.
\item Define $\Delta' := [(h, i) \mapsto T']\Delta$.
% 7.
\item By 4.c), 5.a-b), 6., and WF-Ref1, $\Delta' \vdash r'$.
% 8.
\item By 2.c), 6., 7., and T-SiloRef, $\Gamma ; \Sigma ; \Delta' \vdash r' : \texttt{SiloRef}[T']$.
% 9.
\item By 2.d), 3., 4.a), and 6., $\Gamma ; \Sigma ; \Delta' \vdash \texttt{map}(r, p) : \texttt{SiloRef}[T']$.
% 10.
\item By 1.a), 2.d), 6., $\Gamma ; \Sigma ; \Delta' \vdash t : T$.
% 11.
\item By 2.a-b), 8., 9., 10., $\Gamma ; \Sigma ; \Delta' \vdash t' : T$.
% 12.
\item By 2.e) and 1.b), $\Sigma \vdash \mu'$.
% 13.
\item By 6., $\Delta' \supseteq \Delta$.
% 14.
\item 11., 12., and 13. close this case.
\end{enumerate}

\item Cases R-FMap, R-Persist, and R-Unpersist follow analogously.
\end{itemize}

Part 2: by induction on a derivation of $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$ with case analysis of the last applied rule.

\begin{itemize}

\item Case R-Seq. Then $t = E[s]$.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma ; \Delta \vdash t : T$
  \end{enumerate}
% 3.
\item By R-Seq
  \begin{enumerate}[label=(\alph*)]
  \item $E[s]~|~\mu \rightarrow^h E[s']~|~\mu'$
  \item $Q' = Q$
  \item $S' = S$
  \item $t' = E[s']$
  \end{enumerate}
% 4.
\item By 2.d), 3.a), and part 1
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma' \vdash E[s'] : T$
  \item $\Sigma' \vdash \mu'$
  \item $\Sigma' \supseteq \Sigma$
  \end{enumerate}
% 5.
\item By 2.c), 4.c), and WF-Q1-4, $\Delta ; \Sigma' \vdash Q$.
% 6.
\item By 4.b), 3.c), 2.b), 4.a), 5., and WF-HostConfig, $\Delta ; \Sigma' \vdash (E[s'], \mu', Q, S)^h$.
% 7.
\item 3.d), 4.c), and 6. close this case.
\end{enumerate}

\item Case R-Send1Local.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-Send1Local
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{send}(r)]$
  \item $t' = E[\iota]$
  \item $Q' = Q$
  \item $S' = S$
  \item $host(r) = h$
  \item $S(id(r)) = ({\Val v}, P)$  % 2.f)
  \item $\iota~\text{fresh}$
  \item $\mu' = [\iota \mapsto \text{Some}(v)]\mu$  % 2.h)
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma ; \Delta \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.f), 3.b), and WF-SiloStore2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = T'$
  \item $\emptyset ; \emptyset ; \Delta \vdash v : T'$
  \end{enumerate}
% 5.
\item By 2.a), 3.d), T-Send, $\Gamma ; \Sigma ; \Delta \vdash \texttt{send}(r) : \texttt{Future}[\hat{T}]$.
% 6.
\item By 5. and T-Send, $\Gamma ; \Sigma ; \Delta \vdash r : \texttt{SiloRef}[\hat{T}]$.
% 7.
\item By 6. and T-SiloRef
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \hat{T}$
  \item $\Delta \vdash r$
  \end{enumerate}
% 8.
\item Define $\Sigma' := [\iota \mapsto \texttt{Future}[T']]\Sigma$.
% 9.
\item By 2.h), 3.a), 8., and WF-Store2, $\Sigma' \vdash \mu'$.
% 10.
\item By 2.g), 5., and 8., $\Gamma ; \Sigma' ; \Delta \vdash \texttt{send}(r) : \texttt{Future}[T']$.
% 11.
\item By 8. and T-Loc, $\Gamma ; \Sigma' ; \Delta \vdash \iota : \texttt{Future}[T']$.
% 12.
\item By 2.g), 3.d), 8., $\Gamma ; \Sigma' ; \Delta \vdash t : T$.
% 13.
\item By 2.a-b), 10., 11., and 12., $\Gamma ; \Sigma' ; \Delta \vdash t' : T$.
% 14.
\item By 2.g), 3.c), and 8., $\Delta ; \Sigma' \vdash Q$.
% 15.
\item By 3.b), 9., 13., 14., and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q', S')^h$.
% 16.
\item 8. and 15. close this case.
\end{enumerate}

\item Case R-Send2Local follows analogously.

\item Case R-ReqF1. XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-ReqF1
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota')]$
  \item $t' = t$
  \item $Q = {\ReqF \iota \omega} :: Q'$
  \item $S(\omega) = (\Val{v}, P)$
  \item $S' = {\consume \omega P S}$
  \item $\mu' = [\iota \mapsto \text{Some}(v)]\mu$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.d), 3.b), and WF-SiloStore2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(\omega) = \hat{T}$
  \item $\emptyset ; \emptyset \vdash v : \hat{T}$
  \end{enumerate}
% 5.
\item By 2.c), 3.d), and WF-Q2,
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(\iota) = \texttt{Future}[\hat{T}]$
  \item $\Delta ; \Sigma \vdash Q'$
  \end{enumerate}
% 6.
\item By 2.f), 3.a), 5.a), and WF-Store2, $\Sigma \vdash \mu'$.
% 7.
\item 2.d-e), 3.b), 4.a-b), and WF-SiloStore2, $\Delta \vdash S'$.
% 8.
\item By 2.f), 3.c), 5.a), and WF-Env3, $\Delta ; \Sigma \vdash \mu'$.
% 9.
\item By 6., 7., 8., 5.b), 2.b), 3.e), and WF-HostConfig, $\Delta ; \Sigma \vdash (t', \mu', Q', S')^h$.
% 10.
\item 9. closes this case.
\end{enumerate}

\item Case R-ReqF2 follows analogously.

\item Case R-Res.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-Res
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota)]$
  \item $t' = t$
  \item $Q = {\Res \omega v P} :: Q'$
  \item $S' = [\omega \mapsto (\text{Val}(v), P)]S$
  \item $\mu' = \mu$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.c), 3.d), and WF-Q3
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(\omega) = T'$
  \item $\emptyset ; \emptyset \vdash v : T'$
  \item $\Delta ; \Sigma \vdash Q'$
  \end{enumerate}
% 5.
\item By 2.d), 3.b), 4.a-b), and WF-SiloStore2, $\Delta \vdash S'$.
% 6.
\item By 2.e), 3.a), 5., 3.c), 4.c), 2.b), 3.e), and WF-HostConfig, $\Delta ; \Sigma \vdash (t', \mu', Q', S')^h$.
% 7.
\item 6. closes this case.
\end{enumerate}

\item Case R-Req1Local.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-Req1Local
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota)]$
  \item $t' = t$
  \item $\mu' = \mu$
  \item $Q = {\Req h r \omega} :: Q''$
  \item $Q' = Q'' \cdot {\Res \omega v P}$
  \item $S' = S$
  \item $S(id(r))  = (\Fwd{r'}, P)$
  \item $S(id(r')) = (\Val{v}, P')$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.d), 3.d), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \Delta(\omega)$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 5.
\item By 2.g), 3.b), and WF-SiloStore3, $\Delta(id(r')) = \Delta(id(r))$.
% 6.
\item By 2.h), 3.b), and WF-SiloStore2, $\emptyset ; \emptyset \vdash v : \Delta(id(r))$.
% 7.
\item By 4.a), 6., WF-Q1, and WF-Q3, $\Delta ; \Sigma \vdash {\Res \omega v P} :: \epsilon$.
% 8.
\item By 4.b), 7., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma \vdash Q'' ::: ({\Res \omega v P} :: \epsilon)$.
% 9.
\item By 1.a), 2.b-c), 2.f), 8., and WF-HostConfig, $\Delta ; \Sigma \vdash (t', \mu', Q', S')^h$.
% 10.
\item 9. closes this case.
\end{enumerate}

\item Case R-Req2Local follows analogously.

\item Case R-ReqMapLocal.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-ReqMapLocal
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota)]$
  \item $t' = t$
  \item $\mu' = \mu$
  \item $Q = {\Req {h'} r \omega} :: Q''$
  \item $Q' = Q'' \cdot {\Req {h'} r \omega}$
  \item $r = \text{Mapped}(\omega', r', p)$
  \item $S(id(r')) = ({\Val v}, P)$
  \item $v' = p(v)$  % 2.h)
  \item $S'' = [\omega' \mapsto ({\Val v'}, \emptyset)]S$
  \item $S' = consume(id(r'), P, S'')$  % 2.j)
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.d), 3.d), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \hat{T}$
  \item $\Delta(\omega) = \hat{T}$
  \item $\Delta \vdash r$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 5. 
\item By 2.f) and def. $id$, $id(r) = \omega'$.
% 6.
\item By 2.g), 3.b), and WF-SiloStore2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r')) = T''$
  \item $\emptyset ; \emptyset \vdash v : T''$
  \end{enumerate}
% 7.
\item By 2.f), 4.c) and WF-Ref1, $\emptyset ; \emptyset \vdash p : T'' \Rightarrow \hat{T}~\{\ldots\}$.
% 8.
\item By 2.h), 6.b), 7., and T-AppSpore, $\emptyset ; \emptyset \vdash v' : \hat{T}$.
% 9.
\item By 4.a), 5., 8., 3.b), and WF-SiloStore2, $\Delta \vdash S''$.
% 10.
\item By 2.j), 6.a), 9., and def. $consume$, $\Delta \vdash S'$.
% 11.
\item By 2.c) and 3.c), $\Delta ; \Sigma \vdash \mu'$.
% 12.
\item By 4.a-c), WF-Q1, and WF-Q4, $\Delta ; \Sigma \vdash {\Req {h'} r \omega} :: \epsilon$.
% 13.
\item By 2.e), 4.d), 12., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma \vdash Q'$.
% 14.
\item 2.b-c), 3.a), 3.e), 10., 11., 13., and WF-HostConfig, $\Delta ; \Sigma \vdash (t', \mu', Q', S')^h$.
% 15.
\item 14. closes this case.
\end{enumerate}

\item Case R-ReqFMapLocal follows analogously.

\item Case R-ReqPersistLocal.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-ReqPersistLocal
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota)]$
  \item $t' = t$
  \item $\mu' = \mu$
  \item $Q = {\Req {h'} r \omega} :: Q''$
  \item $Q' = Q'' \cdot {\Res \omega v {P'}}$
  \item $r = {\Per {\omega'} {r'} \star}$  % 2.f)
  \item $\omega'    = (h'', i)$
  \item $S(id(r'))  = (\Val{v}, P)$
  \item $P'         = P \star \{h''\}$
  \item $S''        = [\omega' \mapsto (\Val{v}, P')]S$
  \item $S'         = {\consume {id(r')} P {S''}}$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.d), 3.d), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = T'$
  \item $\Delta(\omega) = T'$
  \item $\Delta \vdash r$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 5.
\item By 2.f), 4.c), and WF-Ref3
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r')) = \hat{T}$
  \item $\Delta(\omega') = \hat{T}$
  \end{enumerate}
% 6.
\item By 2.h), 3.b), 5.a), and WF-SiloStore2, $\emptyset ; \emptyset \vdash v : \hat{T}$.
% 7.
\item By 3.b), 5.b), 6., and WF-SiloStore2, $\Delta \vdash S''$.
% 8.
\item By 2.k), 5.a), 7., and def. $consume$, and WF-SiloStore1-3, $\Delta \vdash S'$.
% 9.
\item By 2.f), 4.a), and 5.b), $T' = \hat{T}$.
% 10.
\item By 4.b), 6., 9., WF-Q1, and WF-Q3, $\Delta ; \Sigma \vdash {\Res \omega v {P'}} :: \epsilon$.
% 11.
\item By 4.d), 10., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma \vdash Q'$.
% 12.
\item By 2.b-c), 3.a,c,e), 8., 11., and WF-HostConfig, $\Delta ; \Sigma \vdash (t', \mu', Q', S')^h$.
% 13.
\item 12. closes this case.
\end{enumerate}

\item Case R-ReqParentLocal.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-ReqPersistLocal
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota)]$
  \item $t' = t$
  \item $\mu' = \mu$
  \item $S' = S$
  \item $Q = {\Req {h'} r \omega} :: Q''$  % 2.e)
  \item $\text{Some}(r') = parent(r)$
  \item $id(r') \notin dom(S)$
  \item $Q' = Q'' \cdot {\Req h {r'} {id(r')}} \cdot {\Req {h'} r \omega}$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.e), 3.d), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = T'$
  \item $\Delta(\omega) = T'$
  \item $\Delta \vdash r$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 5.
\item By 4.a-c), WF-Q1, and WF-Q4, $\Delta ; \Sigma \vdash {\Req {h'} r \omega} :: \epsilon$.
% 6.
\item By 2.f), WF-Ref1-3, $id(r') \in dom(\Delta)$.
% 7.
\item By 2.f), 4.c), and WF-Ref1-3, $\Delta \vdash r'$.
% 8.
\item By 6., 7., WF-Q1, and WF-Q4, $\Delta ; \Sigma \vdash {\Req h {r'} {id(r')}} :: \epsilon$.
% 9.
\item By 5., 8., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma \vdash {\Req h {r'} {id(r')}} :: {\Req {h'} r \omega} :: \epsilon$.
% 10.
\item By 2.h), 4.d), 9., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma \vdash Q'$.
% 11.
\item By 2.b-d), 3.a-c), 3.e), 10., and WF-HostConfig, $\Delta ; \Sigma \vdash (t', \mu', Q', S')^h$.
% 12.
\item 11. closes this case.
\end{enumerate}

\end{itemize}

Part 3: by induction on a derivation of $H \twoheadrightarrow H'$ with case analysis of the last applied rule.

\begin{itemize}
\item Case R-Determ.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta \vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Determ
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (t, \mu, Q, S)^h \} \cup H''$
  \item $H' = \{ (t', \mu', Q', S')^h \} \cup H''$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $\Delta \vdash H''$
  \end{enumerate}
% 4.
\item By 2.c), 3.a), and part 2, $\Delta' ; \Sigma' \vdash (t', \mu', Q', S')^h$ and $\Delta' \supseteq \Delta$.
% 5.
\item By 2.b), 3.b), 4., and WF-Host2, $\Delta' \vdash H'$.
\end{enumerate}

\item Case R-Spawn.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta \vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Spawn
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (t, \mu, Q, S)^h \} \cup H''$
  \item $t = E[\texttt{spawn}(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow s~\})]$
  \item $H' = \{ (t', \mu', Q, S)^h, ((\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow s~\})~\{\}, \epsilon, \epsilon, \epsilon)^{h'} \} \cup H''$
  \item $t' = E[\iota]$
  \item $\iota~\text{fresh}$  % 2.e)
  \item $\mu' = [\iota \mapsto h']\mu$
  \item $h'~\text{fresh}$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $\Delta \vdash H''$
  \end{enumerate}
% 4.
\item By 2.b), 3.a), and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$       % 4.c)
  \item $\Gamma ; \Sigma ; \Delta \vdash t : T'$  % 4.d)
  \end{enumerate}
% 5.
\item By 2.b) and 4.d), $\Gamma ; \Sigma ; \Delta \vdash \texttt{spawn}(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow s~\}) : T''$.
% 6.
\item By 5. and T-Spawn
  \begin{enumerate}[label=(\alph*)]
  \item $T'' = \texttt{Host}$
  \item $\Gamma ; \Sigma ; \Delta \vdash \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow s~\} : (\{\} \Rightarrow \hat{T}~\{~\texttt{type}~\mathcal{C} = \seq{S}~\})$
  \end{enumerate}
% 7.
\item By 6.b) and T-Spore
  \begin{enumerate}[label=(\alph*)]
  \item $T = \{\}$
  \item $\seq{S} = \seq{T}$
  \item $\Gamma ; \Sigma ; \Delta \vdash \seq{v} : \seq{T}$
  \item $\seq{x : T} , x : \{\} ; \emptyset ; \Delta \vdash s : \hat{T}$
  \item $\forall T_i \in \seq{T}.~serializable(T_i)$
  \end{enumerate}
% 8.
\item Define $\Sigma' := [\iota \mapsto \texttt{Host}]\Sigma$.
% 9.
\item By 8. and T-Loc, $\Gamma ; \Sigma' ; \Delta \vdash \iota : \texttt{Host}$.
% 10.
\item By 2.e), 4.d), and 8., $\Gamma ; \Sigma' ; \Delta \vdash t : T'$.
% 11.
\item By 2.b), 2.d), 5., 6.a), 9., and 10., $\Gamma ; \Sigma' ; \Delta \vdash t' : T'$.
% 12.
\item By 2.f), 4.a), 8., and WF-Store2, $\Sigma' \vdash \mu'$.
% 13.
\item By 4.c), 8., and WF-Q1-4, $\Delta ; \Sigma' \vdash Q$.
% 14.
\item By 4.b), 11., 12., 13., and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q, S)^h)$.
% 15.
\item By 7.c), 7.e), and Lemma~\ref{lem:ser-values}, $\emptyset ; \emptyset ; \Delta \vdash \seq{v} : \seq{T}$.
% 16.
\item By 7.d-e), 15., and T-Spore, $\emptyset ; \emptyset ; \Delta \vdash \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow s~\} : (\{\} \Rightarrow \hat{T}~\{~\texttt{type}~\mathcal{C} = \seq{S}~\})$.
% 17.
\item By WF-Store1, WF-SiloStore1, WF-Q1, 16., and WF-HostConfig, $\Delta ; \emptyset \vdash ((\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow s~\})~\{\}, \epsilon, \epsilon, \epsilon)^{h'}$.
% 18.
\item By 3.b), 14., 17., and WF-Host2, $\Delta \vdash H'$.
\end{enumerate}

\item Case R-Populate.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta \vdash H$
  % \Delta \vdash \{ (E[\texttt{populate}(\iota, v)], \mu, Q, S)^h \} \cup (\{ (t', \mu', Q', S')^{h'} \} \cup H'')
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Populate
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (E[\texttt{populate}(\iota, v)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H''$
  \item $H' = \{ (E[\text{Mat}(\omega)], \mu, Q, S)^h, (t', \mu', Q', S'')^{h'} \} \cup H''$
  \item $\mu(\iota) = h'$
  \item $S''        = [\omega \mapsto ({\Val v}, \emptyset)]S'$
  \item $\omega     = (h', i)$
  \item $i~\text{fresh}$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (E[\texttt{populate}(\iota, v)], \mu, Q, S)^h$ for some $\Sigma$
  \item $\Delta \vdash \{ (t', \mu', Q', S')^{h'} \} \cup H''$
  \end{enumerate}
% 4.
\item By 3.b) and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma' \vdash (t', \mu', Q', S')^{h'}$ for some $\Sigma'$
  \item $\Delta \vdash H''$
  \end{enumerate}
% 5.
\item By 3.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma ; \Delta \vdash E[\texttt{populate}(\iota, v)] : T$
  \end{enumerate}
% 6.
\item By 5.d) and T-Populate
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma ; \Delta \vdash \texttt{populate}(\iota, v) : \texttt{SiloRef}[T']$
  \item $\Gamma ; \Sigma ; \Delta \vdash \iota : \texttt{Host}$
  \item $\Gamma ; \Sigma ; \Delta \vdash v : T'$
  \item $serializable(T')$
  \end{enumerate}
% 7.
\item Define $\Delta' := [\omega \mapsto T']\Delta$.
% 8.
\item By 7. and WF-Ref4, $\Delta' \vdash \text{Mat}(\omega)$.
% 9.
\item By 7., 8., and T-SiloRef, $\Gamma ; \Sigma ; \Delta' \vdash \text{Mat}(\omega) : \texttt{SiloRef}[T']$.
% 10.
\item By 2.e-f), 6.a), and 7., $\Gamma ; \Sigma ; \Delta' \vdash \texttt{populate}(\iota, v) : \texttt{SiloRef}[T']$.
% 11.
\item By 2.e-f), 5.d), and 7., $\Gamma ; \Sigma ; \Delta' \vdash E[\texttt{populate}(\iota, v)] : T$.
% 12.
\item By 9., 10., and 11., $\Gamma ; \Sigma ; \Delta' \vdash E[\text{Mat}(\omega)] : T$.
% 13.
\item By 2.e-f), 5.b), and 7., $\Delta' \vdash S$.
% 14.
\item By 2.e-f), 5.c), and 7., $\Delta' ; \Sigma \vdash Q$.
% 15.
\item By 5.a), 13., 14., 12., and WF-HostConfig, $\Delta' ; \Sigma \vdash (E[\text{Mat}(\omega)], \mu, Q, S)^h$.
% 16.
\item By 4.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma' \vdash \mu'$
  \item $\Delta \vdash S'$
  \item $\Delta ; \Sigma' \vdash Q'$
  \item $\Gamma' ; \Sigma' ; \Delta \vdash t' : T''$
  \end{enumerate}
% 17.
\item By 6.c-d) and Lemma~\ref{lem:ser-values}, $\emptyset ; \emptyset ; \Delta \vdash v : T'$.
% 18.
\item By 2.e-f), 7., and 17., $\emptyset ; \emptyset ; \Delta' \vdash v : T'$.
% 19.
\item By 2.e-f), 7., and 16.b), $\Delta' \vdash S'$.
% 20.
\item By 7., 18., 19., and WF-SiloStore2, $\Delta' \vdash S''$
% 21.
\item By 2.e-f), 4.b), 7., 16.c-d)
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta' ; \Sigma' \vdash Q'$
  \item $\Gamma' ; \Sigma' ; \Delta' \vdash t' : T''$
  \item $\Delta' \vdash H''$
  \end{enumerate}
% 22.
\item By 16.a), 20., 21.a-b), and WF-HostConfig, $\Delta' ; \Sigma' \vdash (t', \mu', Q', S'')^{h'}$.
% 23.
\item By 15., 21.c), 22., and WF-Host2, $\Delta' \vdash H'$.
\end{enumerate}

% \inferrule[\textsc{R-Req1}] {
%   Q        = {\Req {h'} r \omega} :: Q''  \quad
%   S(id(r)) = (\Val{v}, P)                 \quad
%   m        = {\Res \omega v P}
% } {
%   \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
%   \twoheadrightarrow
%   \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
% }

\item Case R-Req1.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta \vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Req1
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H''$
  \item $H' = \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H''$
  \item $Q        = {\Req {h'} r \omega} :: Q''$
  \item $S(id(r)) = (\Val{v}, P)$
  \item $m        = {\Res \omega v P}$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q, S)^h$ for some $\Sigma$
  \item $\Delta ; \Sigma' \vdash (t', \mu', Q', S')^{h'}$ for some $\Sigma'$
  \item $\Delta \vdash H''$
  \end{enumerate}
% 4.
\item By 3.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma ; \Delta \vdash E[\texttt{await}(\iota)] : T$
  \end{enumerate}
% 5.
\item By 2.c), 4.c), and WF-Q1-4, $\Delta ; \Sigma \vdash Q''$.
% 6.
\item By 4.a-b), 5., 4.d), and WF-HostConfig, $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q'', S)^h$.
% 7.
\item By 3.b) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma' \vdash \mu'$
  \item $\Delta \vdash S'$
  \item $\Delta ; \Sigma' \vdash Q'$
  \item $\Gamma ; \Sigma' ; \Delta \vdash t' : T'$
  \end{enumerate}
% 8.
\item By 2.d), 4.b), and WF-SiloStore2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \hat{T}$
  \item $\emptyset ; \emptyset ; \Delta \vdash v : \hat{T}$
  \end{enumerate}
% 9.
\item By 2.c), 4.c), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \Delta(\omega)$
  \item $\Delta \vdash r$
  \end{enumerate}
% 10.
\item By 8.a-b), 9.a), WF-Q1, and WF-Q3, $\Delta ; \Sigma' \vdash m :: \epsilon$.
% 11.
\item By 7.c), 10., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma' \vdash Q' \cdot m$.
% 12.
\item By 7.a-b), 11., 7.d), and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q' \cdot m, S')^{h'}$.
% 13.
\item By 3.c), 6., 12., and WF-Host2, $\Delta \vdash H'$.
\end{enumerate}

\end{itemize}

\end{proof}


\newpage

\begin{thm}
\emph{(Lineage Replay)}\label{thm:replay}

If
\begin{itemize}
\item $\emptyset ; \emptyset ; \text{pure} \vdash t : \texttt{SiloRef}[T]$
\item $H_1 := \{ (E_1[send(t)], \mu_1, Q_1, S_1)^h \} \cup H_2$
\item $\vdash H_1$
\item $H_1 \twoheadrightarrow^* \{ (E_1[\iota], \mu_2, Q_2, S_2)^h \} \cup H_3$
\item $\mu_2(\iota) = \text{Some}(v)$
\end{itemize}
then:
\begin{itemize}
\item $H_4 := \{ (E_2[send(t)], \mu_3, Q_3, S_3)^{h'} \} \cup H_5$
\item $\vdash H_4$
\item $H_4 \twoheadrightarrow^* \{ (E_2[\iota], \mu_4, Q_4, S_4)^{h'} \} \cup H_6$
\item $\mu_4(\iota) = \text{Some}(v)$
\end{itemize}

\end{thm}
\begin{proof}
\end{proof}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fault handling.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO Describe how to utilize the herein presented foundation
%      to realize fault tolerance. 

%\begin{figure}[ht!]
%\centering
%\begin{mathpar}
%
%\inferrule[\textsc{RF-Send}] { 
%  host(r) = h'      \quad
%  h' \neq h         \quad
%  \text{failed}(h') \\
%  i~\text{fresh}    \quad
%  \iota = (h, i)    \quad
%  S'' = S + (\iota \mapsto \bot)
%} { 
%  \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \twoheadrightarrow
%  \{ (R[\iota], E, S'')^h \} \cup H
%}
%
%\inferrule[\textsc{RF-Req4}]
%{ 
%  E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
%  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
%}
%{ 
%  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
%}
%
%\inferrule[\textsc{RF-Req5}]
%{ 
%  E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
%  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
%  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
%}
%{ 
%  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\inferrule[\textsc{RF-ReqF}]
%{ 
%  E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
%}
%{ 
%  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%\caption{Fault handling.}
%\end{figure}

%\begin{description}[font=\normalfont\itshape\space]
%\item[\textsc{RF-Send}] ...
%
%\item[\textsc{RF-Req4}] XXX Why $4$?
%
%\item[\textsc{RF-Req5}] ...
%
%\item[\textsc{R-ReqF}] ...
%\end{description}

\end{document}
