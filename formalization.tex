\documentclass{article}
\usepackage{todonotes}
\usepackage{lscape}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bcprules}
\usepackage{mathpartir}
\usepackage{mdframed}

%% Math
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{defn}{Definition}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{prop}{Property}[section]

%% Spacing
\newcommand{\gap}{\quad\quad}

%% Arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

%% Syntax
% Member sequences
\newcommand{\seq}[1]{\overline{#1}}

\begin{document}

\todo[inline]{Turn into a typed calculus}
\todo[inline]{Fix fault tolerance}
\todo[inline]{Fix memory handling\\[2ex] IDEA: provide explicit operators for memory handling; a subsequent static analysis would augment those explicit declaration with further usage of those explicit operators; i.e., a static analysis yields a composition of those memory handling primitives\\[2ex] First approach: incorporate reference counting}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                       & \mbox{{\it{terms:}}} \\                                
\gap \:\:\:\:  x                                                            & \mbox{variable} \\                                
\gap ~|~  (x: T) \Rightarrow t                                              & \mbox{abstraction} \\                                
\gap ~|~  t~t                                                               & \mbox{application} \\                                
\gap ~|~  \texttt{let}~x = t~\texttt{in}~t                                  & \mbox{let binding} \\                                
\gap ~|~  \{ \seq{l = t} \}                                                 & \mbox{record construction} \\                                
\gap ~|~  t.l                                                               & \mbox{selection} \\     
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}       & \mbox{spore} \\     
\gap ~|~  \texttt{map}(r, t[, t])                                           & \mbox{map} \\                          
\gap ~|~  \texttt{flatMap}(r, t[, t])                                       & \mbox{flatMap} \\                          
\gap ~|~  \texttt{send}(t)                                                  & \mbox{send} \\           % send  :: Ref a -> Fut a // returns \iota
\gap ~|~  \texttt{await}(t)                                                 & \mbox{await future} \\   % await :: Fut a -> a                        
\gap ~|~  r                                                                 & \mbox{silo reference} \\                          
\gap ~|~  \iota                                                             & \mbox{future} \\     
                                                                            & \\                                
v ::=                                                                       & \mbox{{\it{values:}}} \\                                
\gap \:\:\:\: (x: T) \Rightarrow t                                          & \mbox{abstraction value} \\                                
\gap ~|~  \{ \seq{l = v} \}                                                 & \mbox{record value} \\                                
\gap ~|~  p                                                                 & \mbox{spore value} \\                                
\gap ~|~  r                                                                 & \mbox{silo reference} \\                                
\gap ~|~  \iota                                                             & \mbox{future} \\     
p ::=     \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}       & \mbox{spore value} \\     
                                                                            & \\                          
T ::=                                                                       & \mbox{{\it{types:}}} \\                          
\gap \:\:\:\: T \Rightarrow T                                               & \mbox{function type} \\                          
\gap ~|~  \{ \seq{l : T} \}                                                 & \mbox{record type} \\                          
\gap ~|~  \mathcal{S}                                                       & \mbox{} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}                    & \mbox{abstract spore type} \\
\ea$

\caption{Abstract syntax of core language.}
\end{figure}

Classification of $r$ and $\iota$ is specified at Figure~\ref{fig:elems-opsem}.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Elements of the operational model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
h \in Hosts                                         & \\   
i \in \mathbb{N}                                    & \\   
                                                    & \\   
\iota  ::=                                          & \mbox{{\it{future values:}}} \\
\gap \:\:\: (h, i)                                  & \mbox{location} \\   
                                                    & \\   
r ::=                                               & \mbox{{\it{silo reference values:}}} \\
\gap \:\:\:\: \text{Mat}(\iota)                     & \mbox{materialized} \\    
\gap ~|~  \text{Mapped}(\iota, r, p, opt_f)         & \mbox{lineage with \texttt{map}} \\    
\gap ~|~  \text{FMapped}(\iota, r, p, opt_f)        & \mbox{lineage with \texttt{flatMap}} \\   
                                                    & \\   
Q      ::=                                          & \mbox{{\it{message queue values:}}} \\
\gap \:\:\:\: \epsilon                              & \mbox{empty queue} \\
\gap ~|~    \text{Res}(\iota, v) \texttt{::} Q      & \mbox{response} \\
\gap ~|~    \text{Req}(h, r, \iota) \texttt{::} Q   & \mbox{request}  \\
\gap ~|~    \text{ReqF}(h, r, \iota) \texttt{::} Q  & \mbox{request (fault)} \\
\ea$

\caption{Elements of the operational model.}
\label{fig:elems-opsem}

\end{figure}

\begin{description}
\item[$\iota$] Encodes latency, in terms of completion of a materialization of a
  silo, as well as the location of the either already materialized or to be
    materialized silo. The location, in turn, serves as the unique,
    decentralized identifier of the respective silo reference.


% << Network communication >>
% val r0: SiloRef[List[Vehicle]] = Silo.fromTextFile(h)("hdfs://...")  ~~> Mat((h,0))
% r0.id    == (h,0)                                                         ^
% host(r0) == h                                                             |
%                                                                           |
% << No network communication >>                                            |
% val r1: SiloRef[List[Vehicle]] = r0 map sp0                          ~~> Mapped((h,1), r0, sp0, None)
% r1.id    == (h,1)
% host(r1) == h
%
% << Network communication >>
% val r2: SiloRef[List[Vehicle]] = Silo.fromTextFile(h)("hdfs://...")  ~~> Mat(???)
% r2.id    ==
% host(r2) == 


\item[$Mat(\iota)$] A silo reference where the referenced silo is already
  materialized, or is to be materialized, at location $\iota$.
  % In this case \iota gives us the location of the materialized silo.

\item[$Mapped(\iota, r, p, opt_f)$] Map spore $p$ over the silo which is
  referenced by $r$. The resulting silo of this transformation is referenced by
    the new silo reference identified by $\iota$. In case of failure at the host
    of the referenced silo apply $opt_f$. % Clearly, \iota is the identifier of
    the new silo reference.

%      r     --> s  @ host(r)
%                ^
%                |
%                | Mapped
%                |
%      r'    --> s' @ host(r) = host(r')
%
% Decentralized identifier of r' is \iota.

\item[$FMapped(\iota, r, p, opt_f)$] Analogous to $Mapped$.
\end{description}

A lineage build up by those silo reference values can be considered as a
{\emph{data flow graph}}\cite{???}.
% Note, verbalisation is imperative to emphasize lazy creation. 

\begin{description}
\item[$Res(\iota, v)$] A response message which instructs the receiver to
  complete future $\iota$ with value $v$.

\item[$Req(h, r, \iota)$] A request message from $h$ which instructs the
  receiver to respond with the materialized silo referenced by $r$; $\iota$
    uniquely identifies the response in terms of the future $\iota$ to be
    completed by the sender of the request.

\item[$ReqF(h, r, \iota)$] Analogous to $Req$.
\end{description}

In the following we introduce a function to backtrack the host of a referenced
silo.

\begin{defn}[Host]
  The function application $host(r)$ obtains the host of the silo referenced by
  $r$; $host$ is defined as follows:
  
  $host(r) := \begin{cases}
    h        & \text{if } r = Mat((h, i)) \\
    host(r') & \text{if } r = Mapped(\_, r', \_, \_) \\
    host(r') & \text{if } r = FMapped(\_, r', \_, \_) \\
    \end{cases}$
\end{defn}

Analogous to~\cite{TAPL}, we introduce the notion of an evaluation context and
write $E[t]$ for the ordinary term obtained by replacing the hole in $E$ with
$t$.

\begin{defn}[Evaluation Context]
  The set of evaluation contexts is defined as follows:
  
 $\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
\gap ~|~  \texttt{let}~x = E~\texttt{in}~t                                                                & \mbox{let (bind)} \\
\gap ~|~  \texttt{let}~x = v~\texttt{in}~E                                                                & \mbox{let (body)} \\
\gap ~|~  \{ \seq{l = v} ; l_i = E ; \seq{l' = t} \}                                                      & \mbox{record} \\
\gap ~|~  E.l                                                                                             & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{map}(E, t[, t])                                                                         & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E[, t])                                                                         & \mbox{map (fun)} \\
\gap ~|~  \texttt{map}(v, v'[, E])                                                                        & \mbox{map (err)} \\
\gap ~|~  \texttt{flatMap}(E, t[, t])                                                                     & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E[, t])                                                                     & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{flatMap}(v, v'[, E])                                                                    & \mbox{flatMap (err)} \\
\ea$ 
\end{defn}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-Map}]
{ 
  host(r) = h \quad i~\text{fresh} \quad r' = \text{Mapped}((h, i), r, p, \text{None}) 
}
{ 
  (E[\texttt{map}(r, p)], Q, S)^h \longrightarrow (E[r'], Q, S)^h
}

\inferrule[\textsc{R-FMap}]
{ 
  host(r) = h \quad i~\text{fresh} \quad r' = \text{FMapped}((h, i), r, p, \text{None})
}
{ 
  (E[\texttt{flatMap}(r, p)], Q, S)^h \longrightarrow (E[r'], Q, S)^h
}

\inferrule[\textsc{R-Await}]
{
  S(\iota) = \text{Some}(v)
}
{
  (E[\texttt{await}(\iota)], Q, S)^h \longrightarrow (E[v], Q, S)^h
}

\inferrule[\textsc{R-Res}]
{
  Q = \text{Res}(\iota, v) \texttt{::} Q' \quad S' = S + (\iota \mapsto v)
}
{
  (E[\texttt{await}(\iota_f)], Q, S)^h \longrightarrow (E[\texttt{await}(\iota_f)], Q', S')^h
}

\inferrule[\textsc{R-ReqLocal}]
{
  Q        = \text{Req}(h', r, \iota'') \texttt{::} Q'    \quad %
  r        = \text{Mapped}(\iota, r', p, \text{None})     \quad %
  r'     \neq \text{Mat}(\iota_s)                         \\ %\quad %
  S(\iota) = \text{None}                                  \\
  loc(r')  = \iota' \quad S(\iota') = \text{None}         \\ % XXX
  Q''      = \text{Req}(h, r', \iota') \texttt{::} Q
}
{ 
  (E[\texttt{await}(\iota_f)], Q, S)^h \rightarrow (E[\texttt{await}(\iota_f)], Q'', S)^h
}
\end{mathpar}
\caption{Deterministic reduction.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Map}] ...

\item[\textsc{R-FMap}] ...

\item[\textsc{R-Await}] ...

\item[\textsc{R-Res}] ...

\item[\textsc{R-ReqLocal}] ...
\end{description}

Note, the reduction rules \textsc{R-Map} and \textsc{R-FMap} do not involve
communication with other hosts.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Non-deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}
\inferrule[\textsc{R-Send}]
{
  host(r) = h' \quad h' \neq h \quad i~\text{fresh} \\
  \iota = (h, i) \quad m = \text{Req}(h, r, \iota)
}
{ 
  \{ (R[\texttt{send}(r)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\iota], E, S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req1}]
{ 
  E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mat}(\iota) \\
  S(\iota) = \text{Some}(v) \quad m = \text{Res}(\iota', v)
}
{ 
  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S)^h, (t, E'' \cdot m, S')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req2}]
{ 
  E = \text{Req}(h', r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r', p, \text{None}) \quad r' = \text{Mat}(\iota_s) \quad S(\iota) = \text{None} \\
  S(\iota_s) = \text{Some}(v) \quad p(v) = v' \quad S' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota', v')
}
{ 
  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E'', S'')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E', S')^h, (t, E'' \cdot m, S'')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req3}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{None} \quad host(r') = h' \quad m = \text{Req}(h, r', \iota') \quad E''' = \text{Req}(h'', r', \iota'') \texttt{::} E''
}
{ 
  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h'} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req4}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, \text{Mat}(\iota_s), p, \text{None}) \quad S(\iota) = \text{None} \quad S(\iota_s) = \text{Some}(v) \\
  \quad p(v) = r' \quad loc(r') = \iota' \quad S(\iota') = \text{Some}(v') \quad S'' = S + (\iota \mapsto v') \quad m = \text{Res}(\iota'', v')
}
{ 
  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h''} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E'', S'')^h, (t, E' \cdot m, S')^{h''} \} \cup H
}

\end{mathpar}
\caption{Non-deterministic reduction.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Send}] ...

\item[\textsc{R-Req1}] ...

\item[\textsc{R-Req2}] ...

\item[\textsc{R-Req3}] ...

\item[\textsc{R-Req4}] ...
\end{description}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fault handling.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering
\begin{mathpar}

\inferrule[\textsc{RF-Send}]
{ 
  host(r) = h' \quad h' \neq h \quad \text{failed}(h') \\
  \quad i~\text{fresh} \quad \iota = (h, i) \quad S'' = S + (\iota \mapsto \bot)
}
{ 
  \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \rightarrow \{ (R[\iota], E, S'')^h \} \cup H
}

\inferrule[\textsc{RF-Req4}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
}
{ 
  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
}

\inferrule[\textsc{RF-Req5}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
}
{ 
  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
}

\inferrule[\textsc{RF-ReqF}]
{ 
  E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
}
{ 
  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
}

\end{mathpar}
\caption{Fault handling.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{RF-Send}] ...

\item[\textsc{RF-Req4}] XXX Why $4$?

\item[\textsc{RF-Req5}] ...

\item[\textsc{R-ReqF}] ...
\end{description}

\end{document}
