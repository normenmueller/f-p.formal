\documentclass{article}
\usepackage{todonotes}
\usepackage{lscape}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bcprules}
\usepackage{mathpartir}
\usepackage{mdframed}

%% Math
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{thm}{Theorem}[section]
\newtheorem{lem}{Lemma}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{defn}{Definition}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{prop}{Property}[section]

\newcommand{\highlight}[1]{%
  \colorbox{gray!50}{$\displaystyle#1$}}

%% Spacing
\newcommand{\gap}{\quad\quad}

%% Arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

%% Syntax
\newcommand{\seq}[1]{\overline{#1}}
\newcommand{\unit}{\texttt{unit}}
\newcommand{\Mat}[1]{\text{Mat}(#1)}
\newcommand{\Mapped}[3]{\text{Mapped}(#1, #2, #3)}
\newcommand{\FMapped}[3]{\text{FMapped}(#1, #2, #3)}

%% Operational model
\newcommand{\Req}[3]{\text{Req}(#1, #2, #3)}
\newcommand{\Res}[2]{\text{Res}(#1, #2)}
\newcommand{\PopReq}[2]{\text{PopReq}(#1, #2)}
\newcommand{\PopRes}[2]{\text{PopRes}(#1, #2)}

%% Persist
\newcommand{\ResP}[3]{\text{Res}(#1, #2, #3)}

\newcommand{\ReqF}[2]{\text{Req}_{\iota}(#1, #2)}
\newcommand{\ReqE}[3]{\text{Req}_f(#1, #2, #3)}
\newcommand{\Per}[3]{\text{Persist}(#1, #2, #3)}

%% Calculus abbreviations
\newcommand{\None}{\text{None}}
\newcommand{\Some}[1]{\text{Some}(#1)}

\newcommand{\Val}[1]{\text{Val}(#1)}
\newcommand{\Fwd}[1]{\text{Fwd}(#1)}

%% Util
\newcommand{\consume}[3]{\text{consume}(#1, #2, #3)}

%% Misc
\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

\begin{document}

\todo[inline]{Conclude Part 2 and 3 of Subject Reduction}
\todo[inline]{Fix fault tolerance}
\todo[inline]{Related work}
\todo[inline]{Verbalize formalization}
\todo[inline]{Fix memory handling\\[2ex] IDEA: provide explicit operators for memory handling; a subsequent static analysis would augment those explicit declaration with further usage of those explicit operators; i.e., a static analysis yields a composition of those memory handling primitives\\[2ex] First approach: incorporate reference counting}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                       & \mbox{{\it{terms:}}} \\                                
\gap \:\:\:\:  x                                                            & \mbox{variable} \\                                
\gap ~|~  (x: T) \Rightarrow t                                              & \mbox{abstraction} \\                                
\gap ~|~  t~t                                                               & \mbox{application} \\                                
%\gap ~|~  \texttt{let}~x = t~\texttt{in}~t                                  & \mbox{let binding} \\                                
\gap ~|~  \{ \seq{l = t} \}                                                 & \mbox{record construction} \\                                
\gap ~|~  t.l                                                               & \mbox{selection} \\
\gap ~|~  \unit                                                             & \mbox{unit} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}       & \mbox{spore} \\
\gap ~|~  \texttt{populate}(t, t)                                           & \mbox{populate silo} \\
\gap ~|~  \texttt{map}(t, t)                                                & \mbox{map} \\                          
\gap ~|~  \texttt{flatMap}(t, t)                                            & \mbox{flatMap} \\                          
\gap ~|~  \texttt{send}(t)                                                  & \mbox{send} \\           % send  :: Ref a -> Fut a
\gap ~|~  \texttt{await}(t)                                                 & \mbox{await future} \\   % await :: Fut a -> a                        
\gap ~|~  \iota                                                             & \mbox{decentralized identifier} \\                          
\gap ~|~  r                                                                 & \mbox{silo reference} \\                          
\gap ~|~  h                                                                 & \mbox{host} \\
                                                                            & \\                                
v ::=                                                                       & \mbox{{\it{values:}}} \\                                
\gap \:\:\:\: (x: T) \Rightarrow t                                          & \mbox{abstraction value} \\                                
\gap ~|~  \{ \seq{l = v} \}                                                 & \mbox{record value} \\                                
\gap ~|~  \unit                                                             & \mbox{unit} \\
\gap ~|~  p                                                                 & \mbox{spore value} \\                                
\gap ~|~  \iota                                                             & \mbox{decentralized identifier} \\
\gap ~|~  r                                                                 & \mbox{silo reference} \\
\gap ~|~  h                                                                 & \mbox{host} \\
                                                                            & \\
p ::= \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}           & \\
                                                                            & \\   
T ::=                                                                       & \mbox{{\it{types:}}} \\                          
\gap \:\:\:\: T \Rightarrow T                                               & \mbox{abstraction type} \\                          
\gap ~|~  \{ \seq{l : T} \}                                                 & \mbox{record type} \\                          
\gap ~|~  \texttt{Unit}                                                     & \mbox{unit type} \\
\gap ~|~  \mathcal{S}                                                       & \mbox{} \\
\gap ~|~  \texttt{Host}                                                     & \mbox{host type} \\
\gap ~|~  \texttt{SiloRef}[T]                                               & \mbox{silo reference type} \\
\gap ~|~  \texttt{Future}[T]                                                & \mbox{future type} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}                    & \mbox{abstract spore type} \\
\ea$

\caption{Abstract syntax of core language.}
\end{figure}

Classification of $r$ and $\iota$ is specified at Figure~\ref{fig:elems-opsem}.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Elements of the operational model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
r ::=                                                  & \mbox{{\it{lineage}}} \\
\gap \:\:\:\: \text{Mat}(\iota)                        & \mbox{materialized} \\    
\gap ~|~  \text{Mapped}(\iota, r, p)                   & \mbox{lineage with \texttt{map}} \\    
\gap ~|~  \text{FMapped}(\iota, r, p)                  & \mbox{lineage with \texttt{flatMap}} \\   
                                                       & \\   
\iota  ::= (h,i) \quad \text{where}~h \in \mathcal{H}~\text{and}~i \in \mathbb{N}   & \mbox{decentralized identifier} \\
\ea$

\caption{Lineages and decentralized identifiers. $\mathcal{H}$ is a countable set of host names.}
\label{fig:elems-opsem}

\end{figure}

\begin{description}
\item[$\iota$] Encodes latency, in terms of completion of a materialization of a silo, as well as the location of the either already materialized or to be materialized silo. The location, in turn, serves as the unique, decentralized identifier of the respective silo reference.

% << Network communication >>
%
%               <<CODE>>                                                    << LINEAGE>>                             <<SILO>>
% Host: h0    
% val r0: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))                   ~~>        h1 
% r0.id    == (h1,0)                                                              ^
% host(r0) == h1                                                                  |
%                                                                                 |
% << No network communication >>                                                  |
%                                                                                 |
% val r1: SiloRef[List[Vehicle]] = r0 map sp0                           ~~>   Mapped((h0,0), r0, sp0, None) ~~>        h1
% r1.id    == (h0,0)      
% host(r1) == h1      
%   
% << Network communication >>   
%   
% val r2: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))
% r2.id    == (h1,0)
% host(r2) == h1 
% r2       == r0

\item[$Mat(\iota)$] A silo reference where the referenced silo is already materialized, or is to be materialized, at location $\iota$.
% (h,i) is the decentralized identifier of the materialized silo hosted at h. In this case \iota gives us the location of the materialized silo.

\item[$Mapped(\iota, r, p)$] Map spore $p$ over the silo which is referenced by $r$. The resulting silo of this transformation is referenced by the new silo reference identified by $\iota$. 

%      r     --> s  @ host(r)
%                ^
%                |
%                | Mapped
%                |
%      r'    --> s' @ host(r) = host(r')
%
% Decentralized identifier of r' is \iota.

\item[$FMapped(\iota, r, p)$] Analogous to $Mapped$.
\end{description}

A lineage build up by those silo reference values can be considered as a {\emph{data flow graph}}\cite{???}. %Note, verbalisation is imperative to emphasize lazy creation. 

\begin{description}
\item[${\Res \iota v}$] A response message which instructs the receiver to complete future $\iota$ with value $v$. % TODO: explain `P`.

\item[${\Req h r \iota}$] A request message from $h$ which instructs the receiver to respond with the materialized silo referenced by $r$; $\iota$ uniquely identifies the response in terms of the future $\iota$ to be completed by the sender of the request.

%\item[$ReqF(h, r, \iota)$] Analogous to $Req$.
\end{description}

In the following we introduce a function to backtrack the host of a referenced silo.

\begin{defn}[Host]\label{def:host}
  The function application $host(r) \in \mathcal{H}$ obtains the host of the silo referenced by $r$; $host$ is defined as follows: \\[1ex]
  $\ba[t]{l@{\hspace{2mm}}l@{\hspace{2mm}}l}
    host(Mat((h, i)))         & = & h \\
    host(Mapped(\_, r', \_))  & = & host(r') \\
    host(FMapped(\_, r', \_)) & = & host(r') \\
  \ea$
\end{defn}

Analogous to~\cite{TAPL}, we introduce the notion of an evaluation context and write $E[t]$ for the ordinary term obtained by replacing the hole in $E$ with $t$. Evaluation contexts capture the notion of the ``next subterm to be reduced.''

\begin{defn}[Evaluation Context]
  The set of evaluation contexts is defined as follows:
  
$\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
%\gap ~|~  \texttt{let}~x = E~\texttt{in}~t                                                                & \mbox{let (bind)} \\
%\gap ~|~  \texttt{let}~x = v~\texttt{in}~E                                                                & \mbox{let (body)} \\
\gap ~|~  \{ \seq{l = v} ; l_i = E ; \seq{l' = t} \}                                                      & \mbox{record} \\
\gap ~|~  E.l                                                                                             & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{populate}(E, t)                                                                         & \mbox{populate (host)} \\
\gap ~|~  \texttt{populate}(v, E)                                                                         & \mbox{populate (spore)} \\
\gap ~|~  \texttt{map}(E, t)                                                                              & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E)                                                                              & \mbox{map (fun)} \\
\gap ~|~  \texttt{flatMap}(E, t)                                                                          & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E)                                                                          & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{send}(E)                                                                                & \mbox{send} \\
\gap ~|~  \texttt{await}(E)                                                                               & \mbox{await} \\
\ea$ 
\end{defn}

\begin{defn}[Decentralized identifier]\label{def:id}
  The function application $id(r) \in \mathcal{H} \times \mathbb{N}$ obtains the decentralized identifier of the silo referenced by $r$; $id$ is defined as follows: \\
  
  $\ba[t]{l@{\hspace{2mm}}l@{\hspace{2mm}}l}
    id(Mat(\iota))             & = & \iota \\
    id(Mapped(\iota, \_, \_))  & = & \iota \\
    id(FMapped(\iota, \_, \_)) & = & \iota \\
  \ea$
\end{defn}

\begin{defn}[Silo reference parent]\label{def:parent}
  The function $parent \in r \rightharpoonup r$ maps a silo, referenced by $r$, to its parent; $parent$ is defined as follows: \\
  
  $\ba[t]{l@{\hspace{2mm}}l@{\hspace{2mm}}l}
    parent(Mapped(\_, r', \_))  & = & r' \\
    parent(FMapped(\_, r', \_)) & = & r' \\
  \ea$
\end{defn}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Lambda reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-AppAbs}] {} {
  E[((x: T) \Rightarrow t)~v']~|~\sigma
  \rightarrow^h
  E[[x \mapsto v']t]~|~\sigma
}

\inferrule[\textsc{R-ProjRcd}] {} {
  E[\{\seq{l_i = v_i^{i \in 1..n}}\}.l_j]~|~\sigma
  \rightarrow^h
  E[v_j]~|~\sigma
}

\inferrule[\textsc{R-AppSpore}] {} {
  E[(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~v']~|~\sigma
  \rightarrow^h
  E[\seq{[x \mapsto v]}[x \mapsto v']t]~|~\sigma
}

\inferrule[\textsc{R-Await}] {
  \sigma(\iota) = \Val v
} {
  E[\texttt{await}(\iota)]~|~\sigma
  \rightarrow^h
  E[v]~|~\sigma
}

\inferrule[\textsc{R-Map}] {
  r' = \text{Mapped}((h, i), r, p) \quad
  i~\text{fresh}
} { 
  E[\texttt{map}(r, p)]~|~\sigma
  \rightarrow^h
  E[r']~|~\sigma
}

\inferrule[\textsc{R-FMap}] { 
  r' = \text{FMapped}((h, i), r, p) \quad
  i~\text{fresh}
} {
  E[\texttt{flatMap}(r, p)]~|~\sigma
  \rightarrow^h
  E[r']~|~\sigma
}

\end{mathpar}
\caption{Sequential reduction.}
\end{figure}

\begin{defn}[Store]\label{def:store}
  $\sigma \in \mathcal{H} \times \mathbb{N} \rightharpoonup \Val{v}\uplus\Fwd{r}$.
\end{defn}

Note, the reduction rules \textsc{R-Map} and \textsc{R-FMap} do not involve communication with other hosts.

TEXT: Man kann, wenn man will zur Optimierung eine Zusatzregel einfuehren fuer send:

\begin{mathpar}
\inferrule[\textsc{R-Send}] {
  host(r) = h                      \quad
  \sigma(id(r)) = \Val{v}
} {
  E[\texttt{send}(r)]~|~\sigma
  \rightarrow^h
  E[id(r)]~|~\sigma
}
\end{mathpar}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define silo store

We write $S' = S + (\iota \mapsto B)$ to express the fact that $S'$ maps $\iota$ to a value $B$ and otherwise agrees with $S$. $B$ is a value of the form $\Val{v}$ or $\Fwd{r}$; the former contains a materialized value $v$, the latter forwards to silo reference $r$, such that $\iota$ is effectively bound to the same value as the identifier of $r$. We write $S(\iota) = \text{Some}(B)$ to express the fact that $S$ maps $\iota$ to $B$. We write $S(\iota) = \text{None}$ if $S$ does not have a mapping for $\iota$.

Our formalization simplifies the computation model with respect to materialized silos. In case of a silo reference of the form $Mat((h, i))$ we assume that there is a mapping in the corresponding silo store $S$, such that $S((h, i)) = \text{Some}(\Val{v}, \{ h \})$ for some value $v$.

\begin{figure}
\centering
$\ba[t]{l@{\hspace{2mm}}l}
m      ::= & \mbox{{\it{message values:}}} \\
\gap \:\:\:\: {\Req h r \iota}      & \mbox{request} \\
\gap ~|~      {\Res \iota v}        & \mbox{response} \\
\gap ~|~      {\PopReq h \iota}     & \mbox{populate request} \\
\gap ~|~      {\PopRes \iota r}     & \mbox{populate response} \\
 & \\
Q      ::=                                             & \mbox{{\it{message queue values:}}} \\
\gap \:\:\:\: \epsilon  & \mbox{empty queue} \\
\gap ~|~    m \cdot Q      & \mbox{non-empty queue} \\
%\gap ~|~    {\ReqF \iota \omega} :: Q                  & \mbox{request (future)}  \\
%\gap ~|~    {\ReqE h r \omega} :: Q                    & \mbox{request (fault)} \\
\ea$
\caption{Message queue}
\end{figure}

% \newcommand\doubleplus{+\kern-1.3ex+\kern0.8ex}
% \newcommand\mdoubleplus{\ensuremath{\mathbin{+\mkern-10mu+}}}

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-Seq}] {
  E[t]~|~\sigma \rightarrow^h E[t']~|~\sigma'
} {
  (E[t], \sigma, Q)^h
  \longrightarrow
  (E[t'], \sigma', Q)^h
}

\inferrule[\textsc{R-SendLocal}] {
  host(r)    = h                         \quad
  id(r) \notin dom(\sigma)
} {
  (E[\texttt{send}(r)], \sigma, Q)^h
  \longrightarrow
  (E[id(r)], \sigma, Q \cdot {\Req h r {id(r)}})^h
}

\inferrule[\textsc{R-ProcQueueLocal}] {
  process(h, m, \sigma) = (\sigma', Q', h)
} {
  (E[\texttt{await}(\iota)], \sigma, m \cdot Q)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \sigma', Q ::: Q')^h
}

\end{mathpar}
\caption{Local reduction.}
\end{figure}

Note: function $process$ is defined via the rules shown in Figure~\ref{fig:process}.

% Note: design approach is to *not* replace Fwds in the silo store, since
% it would require copying data. Instead, we leverage the flexibility of
% Req messages to correctly forward requests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Important that Res message contains correct P, since R-Res
% updates silo store.
% Goal: theorem which states that persist sets are "correct".
% We don't lose hosts from persist sets.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Non-deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% (t, Q, S)^h_c -> <crash>
% H' = { h' | h \in H \land h' = crashed(h_c, h) }
% --------------------------------------------------
%    { (t, Q, S)^h_c } \cup H -->> H'
%
%
% update silo store to reflect crash of h_c
% S' = { id -> (v, C') | id -> (v, C) \in S \land C' = C[h_c -> 0] }
% ---------------------------------------------------------------------
%    crashed(h_c, (t, Q, S)^h) = (t, Q, S')^h
%
%
%   S(id) =  Some(v)       |  None
%
%   S(id) = (Some(v), cnt) | (None, cnt)
%
%   S(id) = (Some(v), [h -> 3, h' -> 2]) | (None, ...)
%
%   S(id) = (Some(v), C)   | (None, C)


\begin{figure}[ht!]
\begin{mathpar}

% R-Req1
\inferrule[\textsc{Proc-Req}] {
  \sigma(id(r)) = \Val{v}         \quad
  m'            = {\Res \iota v}  \quad
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma, m' \cdot \epsilon, h')
}

% R-ReqMat
\inferrule[\textsc{Proc-ReqMat}] {
  r = {\Mat {\iota'}}         \quad
  host(r) = h                 \quad
  \iota' \notin dom(\sigma)
} {
  process(h, {\Req h r \iota}, \sigma) = (\sigma, {\Req h r \iota} \cdot \epsilon, h)
}

% R-ReqMap
\inferrule[\textsc{Proc-ReqMap}] {
  r               = \text{Mapped}(\iota', r', p)    \quad
  \sigma(id(r'))  = \Val{v}                         \quad
  v'              = p(v)                            \quad
  \sigma'         = [\iota' \mapsto \Val{v'}]\sigma
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma', {\Req {h'} r \iota} \cdot \epsilon, h)
}

% R-ReqFMap
\inferrule[\textsc{Proc-ReqFMap}] {
  r               = \text{FMapped}(\iota', r', p) \quad
  \sigma(id(r'))  = \Val{v} \quad
  r''             = p(v)    \quad
  \sigma'         = [\iota' \mapsto \Fwd{r''}]\sigma
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma', {\Req {h'} {r''} \iota} \cdot \epsilon, h)
}

% R-Req3 + (R-ReqLocal w/ h' == h und h'' == h)
\inferrule[\textsc{Proc-ReqFwd}] {
  \sigma(id(r)) = \Fwd{r'}                 \quad
  h'            = host(r')                 \quad
  m'            = {\Req {h''} {r'} \iota}  \quad
} {
  process(h, {\Req {h''} r \iota}, \sigma) = (\sigma, m' \cdot \epsilon, h')
}

% R-ReqParent
\inferrule[\textsc{Proc-ReqParent}] {
  r' = parent(r)                  \quad %
  id(r') \notin dom(\sigma)
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma, {\Req h {r'} {id(r')}} \cdot {\Req {h'} r \iota} \cdot \epsilon, h)
}

% R-Res
\inferrule[\textsc{Proc-Res}] {
  \sigma' = [\iota \mapsto \Val{v}]\sigma
} {
  process(h, {\Res \iota v}, \sigma) = (\sigma', \epsilon, h)
}

% R-PopResLocal
\inferrule[\textsc{Proc-PopRes}] {
  \sigma' = [\iota \mapsto {\Fwd r}]\sigma
} {
  process(h, {\PopRes {\iota} r}, \sigma) = (\sigma', \epsilon, h)
}

% R-PopRes
\inferrule[\textsc{Proc-PopReq}] {
  \iota   = (h, i)                \quad i~\text{fresh} \quad
  r       = \text{Mat}(\iota)     \quad
  m'      = {\PopRes {\iota'} r}  \quad
  \sigma' = [\iota \mapsto {\Val \unit}]\sigma
} {
  process(h, {\PopReq {h'} {\iota'}}, \sigma) = (\sigma', m' \cdot \epsilon, h')
}

\end{mathpar}
\caption{Message processing.}\label{fig:process}
\end{figure}

\begin{defn}[Message processing]
  The function $process \in \mathcal{H} \times m \times S  \rightharpoonup S \times Q \times \mathcal{H}$ handles the processing of a message resulting in a new message queue and a new store; here, $S = \mathcal{H} \times \mathbb{N} \rightharpoonup \Val{v} \uplus \Fwd{r}$ is the type of a store (see Def.~\ref{def:store}). $process$ is defined in Fig.~\ref{fig:process}.
\end{defn}

\begin{figure}[ht!]
\begin{mathpar}
\inferrule[\textsc{R-Local}] {
  (t, \sigma, Q)^h \rightarrow (t', \sigma', Q')^h
} { 
  \{ (t, \sigma, Q)^h \} \cup H
  \twoheadrightarrow
  \{ (t', \sigma', Q')^h \} \cup H
}

\inferrule[\textsc{R-PopulateRemote}] {
  \iota = (h, i) \quad i~\text{fresh} \quad
  r     = {\Mat \iota}                \quad
  m     = {\PopReq h \iota }
} {
  \{ (E[\texttt{populate}(h')], \sigma, Q)^h, (t', \sigma', Q')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[r], \sigma, Q)^h, (t', \sigma', Q' \cdot m)^{h'} \} \cup H
}

\inferrule[\textsc{R-SendRemote}] {
  host(r) = h'                          \quad
  h' \neq h                             \quad
  m = {\Req h r {id(r)}}
} {
  \{ (E[\texttt{send}(r)], \sigma, Q)^h, (t', \sigma', Q')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[id(r)], \sigma, Q)^h, (t', \sigma', Q' \cdot m)^{h'} \} \cup H
}

\inferrule[\textsc{R-ProcQueueRemote}] {
  process(h, m, \sigma) = (\sigma'', Q'', h')
} {
  \{ (E[\texttt{await}(\iota)], \sigma, m \cdot Q)^h, (t', \sigma', Q')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota)], \sigma'', Q)^h, (t', \sigma', Q' ::: Q'')^{h'} \} \cup H
}

\end{mathpar}
\caption{Remote reduction.}
\end{figure}

ACHTUNG: wir muessen unbedingt erwaehnen, dass all -Remote Regeln jeweils nur asynchrone Nachrichten verschicken! Ansonsten keine Aenderung in h'.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Type assignment.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}

\inferrule[\textsc{S-Record}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(\{ \seq{l : T} \})
}

\inferrule[\textsc{S-Spore}] {
  \forall T_i \in \seq{T}.~serializable(T_i)
} {
  serializable(T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
}

\inferrule[\textsc{S-SiloRef}] {} {
  serializable(\texttt{SiloRef}[T])
}

\end{mathpar}
\caption{Serializable types.}
\end{figure}


\begin{figure}[ht!]
\begin{mathpar}
% variable
\inferrule[\textsc{T-Var}] {
  x : T \in \Gamma
} { 
  \Gamma ; \Sigma \vdash x : T
}

\inferrule[\textsc{T-Ident}] {
  \Sigma(\iota) = T
} {
  \Gamma ; \Sigma \vdash \iota : \texttt{Future}[T]
}

% abstraction
\inferrule[\textsc{T-Abs}] {
  \Gamma, x : T ; \Sigma \vdash t : T'
} {
  \Gamma ; \Sigma \vdash ((x: T) \Rightarrow t) : T \Rightarrow T'
}

% application
\inferrule[\textsc{T-App}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T' \quad
  \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

% record
\inferrule[\textsc{T-Record}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T}
} {
  \Gamma ; \Sigma \vdash \{ \seq{l = t} \} : \{ \seq{l : T} \}
}

% selection
\inferrule[\textsc{T-Select}] {
  \Gamma ; \Sigma \vdash t : \{ \seq{l : T} \}
} {
  \Gamma ; \Sigma \vdash t.l_i : T_i
}

% unit
\inferrule[\textsc{T-Unit}] {
} {
  \Gamma ; \Sigma \vdash \unit : \texttt{Unit}
}

% spore
\inferrule[\textsc{T-Spore}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T}     \quad
  \seq{x : T}, x : T ; \emptyset \vdash t : T' \quad
  \forall S \in \seq{T} , T'.~serializable(S)
} {
  \Gamma ; \Sigma \vdash (\texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}) : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}
}

\inferrule[\textsc{T-AppSpore}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\} \quad
  \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

% populate
% TODO make async (Future[SiloRef[T]]); cf. R-Populate
\inferrule[\textsc{T-Populate}] {
  \Gamma ; \Sigma \vdash t : \texttt{Host}
} {
  \Gamma ; \Sigma \vdash \texttt{populate}(t) : \texttt{SiloRef}[\texttt{Unit}]
}

% map
\inferrule[\textsc{T-Map}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma \vdash t' : (T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{map}(t, t') : \texttt{SiloRef}[T']
}

% flatMap
\inferrule[\textsc{T-FMap}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad
  \Gamma ; \Sigma \vdash t' : (T \Rightarrow \texttt{SiloRef}[T']~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{flatMap}(t, t') : \texttt{SiloRef}[T']
}

% send
\inferrule[\textsc{T-Send}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{send}(t) : \texttt{Future}[T]
}

\inferrule[\textsc{T-SiloRef}] {
  \Sigma(id(r)) = T \quad
  \Sigma \vdash r
} {
  \Gamma ; \Sigma \vdash r : \texttt{SiloRef}[T]
}

% await
\inferrule[\textsc{T-Await}] {
  \Gamma ; \Sigma \vdash t : \texttt{Future}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{await}(t) : T
}

\end{mathpar}
\caption{Type assignment.}
\end{figure}

\begin{defn}[Store Typing]
  $\Sigma \in \mathcal{H} \times \mathbb{N} \rightharpoonup T$.
\end{defn}


\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Subject reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}

\inferrule[\textsc{WF-Store1}] {} {
  \emptyset \vdash \emptyset
}

\inferrule[\textsc{WF-Store2}] {
  \Sigma \vdash \sigma
} {
  [\iota \mapsto T]\Sigma \vdash [\iota \mapsto v]\sigma
}

\inferrule[\textsc{WF-Ref1}] {
  \Sigma(\iota) = T  \quad
  \Sigma(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma \vdash p : T' \Rightarrow T~\{\ldots\} \quad
  \Sigma \vdash r
} {
  \Sigma \vdash \text{Mapped}(\iota, r, p)
}

\inferrule[\textsc{WF-Ref2}] {
  \Sigma(\iota) = T  \quad
  \Sigma(id(r)) = T' \quad
  \exists \Gamma, \Sigma.~\Gamma ; \Sigma \vdash p : T' \Rightarrow \texttt{SiloRef}[T]~\{\ldots\} \quad
  \Sigma \vdash r
} {
  \Sigma \vdash \text{FMapped}(\iota, r, p)
}

\inferrule[\textsc{WF-Ref3}] {
  \iota \in dom(\Sigma)
} {
  \Sigma \vdash {\text{Mat}(\iota)}
}

\inferrule[\textsc{WF-SiloStore1}] {} {
  \Sigma \vdash \emptyset
}

\inferrule[\textsc{WF-SiloStore2}] {
  \Sigma(\iota) = T                   \quad
  \emptyset ; \emptyset \vdash v : T  \quad
  \Sigma \vdash \sigma
} {
  \Sigma \vdash [\iota \mapsto {\Val v}]\sigma
}

\inferrule[\textsc{WF-SiloStore3}] {
  \Sigma(id(r)) = \Sigma(\iota)      \quad
  \Sigma \vdash r                    \quad
  \Sigma \vdash \sigma
} {
  \Sigma \vdash [\iota \mapsto {\Fwd r}]\sigma
}

\inferrule[\textsc{WF-Q1}] {} {
  \Sigma \vdash \epsilon
}

\inferrule[\textsc{WF-Q2}] {
  \Sigma(\iota) = T                   \quad
  \emptyset ; \emptyset \vdash v : T  \quad
  \Sigma \vdash Q
} {
  \Sigma \vdash {\Res \iota v} \cdot Q
}

\inferrule[\textsc{WF-Q3}] {
  \Sigma(id(r)) = \Sigma(\iota) \quad
  \Sigma \vdash r \quad
  \Sigma \vdash Q
} {
  \Sigma \vdash {\Req h r \iota} \cdot Q
}

\inferrule[\textsc{WF-HostConfig}] {
  \Sigma \vdash \sigma  \quad
  \Sigma \vdash Q       \quad
  \Gamma ; \Sigma \vdash t : T
} {
  \Sigma \vdash (t, \sigma, Q)^h
}

\inferrule[\textsc{WF-Host1}] {} { 
  \Sigma \vdash \emptyset
}

\inferrule[\textsc{WF-Host2}] {
  \Sigma \vdash (t, \sigma, Q)^h  \quad
  \Sigma \vdash H
} {
  \Sigma \vdash \{ (t, \sigma, Q)^h \} \cup H
}
% was wir ausschliessen muessen ist: \Sigma(\iota') \neq \Sigma'(\iota') fuer zwei verschiedene Hosts

\end{mathpar}
\caption{Well-formedness.}
\end{figure}

\section{Persist and Unpersist}

\subsection{Syntax}

\begin{figure}
  \centering
$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                     & \mbox{{\it terms:}}         \\
\gap \:\:\:\: \ldots                      & \mbox{} \\
\gap ~|~ \texttt{persist}(t)              & \mbox{persist}     \\
\gap ~|~ \texttt{unpersist}(t)            & \mbox{unpersist}     \\
\ea$
  \caption{Syntax extensions for persist/unpersist.}
  \label{fig:persist-syntax}
\end{figure}

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
r ::=                                    & \mbox{{\it{lineage:}}} \\
\gap \:\:\:\: \ldots                     & \mbox{} \\
\gap ~|~  \text{Persist}(\iota, r, f)    & \mbox{lineage with \texttt{persist}} \\    
\ea$

\caption{Extension of lineages. $f$ is a binary operator with $f \in \{\cdot\cup\cdot, \cdot\setminus\cdot\}.$}
\end{figure}

\subsection{Reduction}

\begin{defn}[Host]
  Definition~\ref{def:host} is hereby extended to handle the following additional case: $host(Persist(\_, r', \_)) = host(r')$
\end{defn}

\begin{defn}[Evaluation Context]
  The set of evaluation contexts is defined as follows:
  
$\ba[t]{l@{\hspace{2mm}}l}
E ::=                             & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: \ldots              & \mbox{} \\
\gap ~|~  \texttt{persist}(E)     & \mbox{persist} \\
\gap ~|~  \texttt{unpersist}(E)   & \mbox{unpersist} \\
\ea$ 
\end{defn}

\begin{defn}[Decentralized identifier]
  Definition~\ref{def:id} is hereby extended to handle the following additional case: $id(Persist(\iota, \_, \_)) = \iota$
\end{defn}

\begin{defn}[Silo reference parent]
  Definition~\ref{def:parent} is hereby extended to handle the following additional case: $parent(Persist(\_, r', \_)) = r'$
\end{defn}

\begin{defn}[Consume silo]\label{def:consume}
Consume silo referenced by $\iota$ with persist set $P$ in store $\sigma$ \\
$consume(\iota, P, \sigma) := \begin{cases}
\sigma - \iota & \text{if } P = \emptyset \\
\sigma         & \text{otherwise} \\
\end{cases}$
\end{defn}

\begin{defn}[Store]\label{def:store2}
  $\sigma \in \mathcal{H} \times \mathbb{N} \rightharpoonup (\Val{v}\uplus\Fwd{r}) \times \mathcal{P}(\mathcal{H})$.
\end{defn}

\begin{figure}
\centering
\begin{mathpar}
\inferrule[\textsc{R-Persist}] {
  r' = \text{Persist}((h, i), r, \cdot \cup \cdot) \quad
  i~\text{fresh}
} {
  E[\texttt{persist}(r)]~|~\sigma
  \rightarrow^h
  E[r']~|~\sigma
}

\inferrule[\textsc{R-Unpersist}] {
  r' = \text{Persist}((h, i), r, \cdot \setminus \cdot) \quad
  i~\text{fresh}
} {
  E[\texttt{unpersist}(r)]~|~\sigma
  \rightarrow^h
  E[r']~|~\sigma
}
\end{mathpar}
\caption{Extensions of sequential reduction.}\label{fig:persist-seq-reduction}
\end{figure}

\begin{figure}
\centering
\begin{mathpar}
\inferrule[\textsc{Proc-Req}] {
  \sigma(id(r)) = \highlight{(\Val{v}, P)}       \quad
  \sigma'       = {\consume {id(r)} P \sigma}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma', \highlight{{\ResP \iota v P}} \cdot \epsilon, h')
}

\inferrule[\textsc{Proc-ReqMap}] {
  r               = \text{Mapped}(\iota', r', p)    \quad
  \sigma(id(r'))  = \highlight{(\Val{v}, P)}        \quad
  v'              = p(v)                            \quad
  \\
  \sigma'         = [\iota' \mapsto \highlight{(\Val{v'}, \emptyset)}]\sigma \quad
  \sigma''        = {\consume {id(r')} P {\sigma'}}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma'', {\Req {h'} r \iota} \cdot \epsilon, h)
}

\inferrule[\textsc{Proc-ReqFMap}] {
  r               = \text{FMapped}(\iota', r', p) \quad
  \sigma(id(r'))  = \highlight{(\Val{v}, P)}      \quad
  r''             = p(v)                          \quad
  \\
  \sigma'         = [\iota' \mapsto \highlight{(\Fwd{r''}, \emptyset)}]\sigma \quad
  \sigma''        = {\consume {id(r')} P {\sigma'}}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma'', {\Req {h'} {r''} \iota} \cdot \epsilon, h)
}

\inferrule[\textsc{Proc-ReqFwd}] {
  \sigma(id(r)) = \highlight{(\Fwd{r'}, P)} \quad
  h'            = host(r')                  \quad
} {
  process(h, {\Req {h''} r \iota}, \sigma) = (\sigma, {\Req {h''} {r'} \iota} \cdot \epsilon, h')
}

\inferrule[\textsc{Proc-ReqParent}] {
  r' = parent(r)                  \quad %
  id(r') \notin dom(\sigma)
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma, {\Req h {r'} {id(r')}} \cdot {\Req {h'} r \iota} \cdot \epsilon, h)
}

\inferrule[\textsc{Proc-Res}] {
  \sigma' = [\iota \mapsto \highlight{(\Val{v}, P)}]\sigma
} {
  process(h, \highlight{{\ResP \iota v P}}, \sigma) = (\sigma', \epsilon, h)
}

\inferrule[\textsc{Proc-PopRes}] {
  \sigma' = [\iota \mapsto \highlight{({\Fwd r}, \emptyset)}]\sigma
} {
  process(h, {\PopRes {\iota} r}, \sigma) = (\sigma', \epsilon, h)
}

\inferrule[\textsc{Proc-PopReq}] {
  \iota   = (h, i)                \quad i~\text{fresh} \quad
  r       = \text{Mat}(\iota)     \quad
  \sigma' = [\iota \mapsto \highlight{({\Val \unit}, \emptyset)}]\sigma
} {
  process(h, {\PopReq {h'} {\iota'}}, \sigma) = (\sigma', {\PopRes {\iota'} r} \cdot \epsilon, h')
}

\inferrule[\textsc{Proc-ReqPersist}] {
  r              = {\Per {\iota'} {r'} \star}  \quad
  \iota'         = (h'', i)                    \quad
  \sigma(id(r')) = \highlight{(\Val{v}, P)}                \quad
  P'             = P \star \{h''\}             \\
  \sigma'        = [\iota' \mapsto \highlight{(\Val{v}, P')}]\sigma  \quad
  \sigma''       = {\consume {id(r')} P {\sigma'}}
} {
  process(h, {\Req {h'} r \iota}, \sigma) = (\sigma'', \highlight{{\ResP \iota v {P'}}} \cdot \epsilon, h')
}
\end{mathpar}
\caption{Extension of message processing.}\label{fig:persist-process}
\end{figure}

\subsection{Typing and Well-Formedness}

\begin{figure}[h]
\centering
\begin{mathpar}
\inferrule[\textsc{T-Persist}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{persist}(t) : \texttt{SiloRef}[T]
}

\inferrule[\textsc{T-UnPersist}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{unpersist}(t) : \texttt{SiloRef}[T]
}
\end{mathpar}
\caption{Extension of typing.}\label{fig:persist-typing}
\end{figure}

\begin{figure}[h]
\centering
\begin{mathpar}
\inferrule[\textsc{WF-Ref4}] {
  \Sigma(\iota) = T  \quad
  \Sigma(id(r)) = T  \quad
  \Sigma \vdash r
} {
  \Sigma \vdash {\Per \iota r {\star}}
}

\inferrule[\textsc{WF-SiloStore2}] {
  \Sigma(\iota) = T                   \quad
  \emptyset ; \emptyset \vdash v : T  \quad
  \Sigma \vdash \sigma
} {
  \Sigma \vdash [\iota \mapsto {\highlight{(\Val v, P)}}]\sigma
}

\inferrule[\textsc{WF-SiloStore3}] {
  \Sigma(id(r)) = \Sigma(\iota)      \quad
  \Sigma \vdash r                    \quad
  \Sigma \vdash \sigma
} {
  \Sigma \vdash [\iota \mapsto {\highlight{(\Fwd r, P)}}]\sigma
}

\inferrule[\textsc{WF-Q2}] {
  \Sigma(\iota) = T                   \quad
  \emptyset ; \emptyset \vdash v : T  \quad
  \Sigma \vdash Q
} {
  \Sigma \vdash {\highlight{\ResP \iota v P}} :: Q
}
\end{mathpar}
\caption{Extension of well-formedness.}\label{fig:persist-wf}
\end{figure}

\newpage
\section{Appendix}

\begin{lem}
\emph{(Substitution)}\label{th:subst}
If $\Gamma , x : T' ; \Sigma \vdash t : T$ and $\Gamma ; \Sigma \vdash v : T'$ then $\Gamma ; \Sigma \vdash [x \mapsto v]t : T$.
\end{lem}
\begin{proof}
By induction on the derivation of $\Gamma , x : T' ; \Sigma \vdash t : T$.
\end{proof}

\begin{lem}
\emph{(Queue Concat)}\label{lem:queue-concat}
If $\Sigma \vdash Q$ and $\Sigma \vdash Q'$ then $\Sigma \vdash Q ::: Q'$.
\end{lem}
\begin{proof}
By induction on the length of $Q$. The case where $Q = \epsilon$ is trivial.

Case $Q = m \cdot Q''$.
\begin{enumerate}
\item[A1.] By WF-Q1-3, $\Sigma \vdash Q''$.
\item[A2.] By the IH, $\Sigma \vdash Q'' ::: Q'$.
\end{enumerate}

\begin{itemize}
\item Case $m = {\ResP \iota v P}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q2
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(\iota) = T$
  \item $\emptyset ; \emptyset \vdash v : T$
  \item $\Sigma \vdash Q''$
  \end{enumerate}
% 2.
\item By A2., 1.a-b), and WF-Q2, $\Sigma \vdash m \cdot Q'' ::: Q'$.
\end{enumerate}

\item Case $m = {\Req h r \iota}$.
\begin{enumerate}
% 1.
\item By the assumption and WF-Q3
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(id(r)) = \Sigma(\iota)$
  \item $\Sigma \vdash r$
  \item $\Sigma \vdash Q''$
  \end{enumerate}
% 2.
\item By A2., 1.a-b), and WF-Q3, $\Sigma \vdash m \cdot Q'' ::: Q'$.
\end{enumerate}
\end{itemize}
\end{proof}

\begin{lem}
\emph{(Queue Ordering)}\label{lem:queue-ordering}
If $\Sigma \vdash m \cdot Q$ then $\Sigma \vdash Q \cdot m$.
\end{lem}
\begin{proof}
By the assumption and WF-Q1-3, $\Sigma \vdash m \cdot \epsilon$ and $\Sigma \vdash Q$. By Lemma~\ref{lem:queue-concat}, $\Sigma \vdash Q ::: (m \cdot \epsilon)$.
\end{proof}

\begin{lem}
\emph{(Serializable Values)}\label{lem:ser-values}
If $\Gamma ; \Sigma \vdash v : T$ and $serializable(T)$ then $\emptyset ; \emptyset \vdash v : T$.
\end{lem}
\begin{proof}
By induction on a derivation of $\Gamma ; \Sigma \vdash v : T$ with a case analysis on the last applied rule.

\begin{itemize}
\item Case \textsc{T-SiloRef} follows trivially.

\item Case \textsc{T-Record}.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash v : T$
  \item $serializable(T)$
  \end{enumerate}
% 2.
\item By \textsc{T-Record}
  \begin{enumerate}[label=(\alph*)]
  \item $v = \{\seq{l = v}\}$
  \item $T = \{\seq{l : T}\}$
  \item $\Gamma ; \Sigma \vdash \seq{v} : \seq{T}$
  \end{enumerate}
% 3.
\item By 2.b) and \textsc{S-Record}, $\forall T_i \in \seq{T}.~serializable(T_i)$.
% 4.
\item By 2.c), 3., and the IH, $\emptyset ; \emptyset \vdash \seq{v} : \seq{T}$.
% 5.
\item By 4. and \textsc{T-Record}, $\emptyset ; \emptyset \vdash \{\seq{l = v}\} : \{\seq{l : T}\}$.
\end{enumerate}

\item Case \textsc{T-Spore} is analogous to case \textsc{T-Record}.
\end{itemize}
\end{proof}

\begin{lem}
\emph{(Weakening of Store Typing)}\label{lem:weakening-store-typing}
If $\Gamma ; \Sigma \vdash t : T$ and $\iota \notin \Sigma$ then $\Gamma ; \Sigma' \vdash t : T$ where $\Sigma' = [\iota \mapsto T]\Sigma$.
\end{lem}
\begin{proof}
By induction on the derivation of $\Gamma ; \Sigma \vdash t : T$.
\end{proof}

\begin{lem}\emph{(Process)}\label{lem:process}
If $\Sigma \vdash \sigma$, $\Sigma \vdash m \cdot \emptyset$, and $process(h, m, \sigma) = (\sigma', Q', h')$ then $\Sigma' \vdash \sigma'$ and $\Sigma' \vdash Q'$ for some $\Sigma' \supseteq \Sigma$.
\end{lem}
\begin{proof}
\begin{itemize}
\item Case Proc-Req.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \sigma$
  \item $\Sigma \vdash m \cdot \emptyset$
  \item $process(h, m, \sigma) = (\sigma', Q', h')$
  \end{enumerate}
% 2.
\item By Proc-Req
  \begin{enumerate}[label=(\alph*)]
  \item $m = {\Req {h'} r \iota}$
  \item $\sigma(id(r)) = ({\Val v}, P)$
  \item $m' = {\ResP \iota v P}$
  \item $Q' = m' \cdot \epsilon$
  \item $\sigma' = consume(id(r), P, \sigma)$
  \end{enumerate}
% 3.
\item Define $\Sigma' := \Sigma$.
% 4.
\item By 2.e) and Def.~\ref{def:consume}, $dom(\sigma') \subseteq dom(\sigma)$.
% 5.
\item By 1.a), 3., 4., and WF-SiloStore1-3, $\Sigma' \vdash \sigma'$.
% 6.
\item By 1.b), 2.a), WF-Q1, and WF-Q3
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(id(r)) = \Sigma(\iota)$
  \item $\Sigma \vdash r$
  \end{enumerate}
% 7.
\item $T := \Sigma(id(r))$.
% 8.
\item By 1.a), 2.b), 7., and WF-SiloStore2, $\emptyset ; \emptyset \vdash v : T$.
% 9.
\item By 2.c-d), 6.a), 7., 8., WF-Q1, and WF-Q2, $\Sigma \vdash Q'$.
% 10.
\item 1.a), 2.e), 3., and 9. close this case.
\end{enumerate}

\item Cases Proc-ReqMat, Proc-ReqFwd, Proc-ReqParent follow analogously.

\item Case Proc-ReqMap.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \sigma$
  \item $\Sigma \vdash m \cdot \emptyset$
  \item $process(h, m, \sigma) = (\sigma'', Q', h')$
  \end{enumerate}
% 2.
\item By Proc-ReqMap
  \begin{enumerate}[label=(\alph*)]
  \item $m = {\Req {h'} r \iota}$
  \item $r = {\Mapped {\iota'} {r'} p}$
  \item $\sigma(id(r')) = ({\Val v}, P)$
  \item $v' = p(v)$
  \item $\sigma' = [\iota' \mapsto ({\Val {v'}}, \emptyset)]\sigma$
  \item $Q' = {\Req {h'} r \iota} \cdot \epsilon$
  \item $\sigma'' = consume(id(r'), P, \sigma')$
  \end{enumerate}
% 3.
\item By 1.b), 2.a), WF-Q1, and WF-Q3
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(id(r)) = \Sigma(\iota)$
  \item $\Sigma \vdash r$
  \end{enumerate}
% 4.
\item By 2.b), 3.b), and WF-Ref1
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(\iota') = T$
  \item $\Sigma(id(r')) = T'$
  \item $\exists \Gamma, \Sigma.~\Gamma ; \Sigma \vdash p : T' \Rightarrow T~\{\ldots\}$
  \item $\Sigma \vdash r'$
  \end{enumerate}
% 5.
\item Define $\Sigma' := \Sigma$.
% 6.
\item By 3.a-b), 5., WF-Q1, and WF-Q3, $\Sigma' \vdash {\Req {h'} r \iota} \cdot \epsilon$.
% 7.
\item By 1.a), 2.c), 4.b), and WF-SiloStore2, $\emptyset ; \emptyset \vdash v : T'$.
% 8.
\item By 2.d), 4.c), 7., and T-AppSpore, $\Gamma, \Sigma \vdash v' : T$.
% 9.
\item By 4.c) and T-Spore, $serializable(T)$.
% 10.
\item By 8., 9., and Lemma~\ref{lem:ser-values}, $\emptyset ; \emptyset \vdash v' : T$.
% 11.
\item By 1.a), 2.e), 4.a), 5., 10., and WF-SiloStore2, $\Sigma' \vdash \sigma'$.
% 12.
\item By 2.g) and Def.~\ref{def:consume}, $dom(\sigma'') \subseteq dom(\sigma')$, and therefore by 11., $\Sigma' \vdash \sigma''$.
% 13.
\item 5., 6., and 12. close this case.
\end{enumerate}

% TODO: expand for debugging
\item Cases Proc-ReqFMap, Proc-Res, Proc-PopRes, and Proc-PopReq follow analogously.

\end{itemize}
\end{proof}

\begin{thm}
\emph{(Subject Reduction)}\label{th:pres}

\begin{enumerate}

\item If $\Gamma ; \Sigma \vdash t : T$, $\Sigma \vdash \sigma$, and $t~|~\sigma \rightarrow^h t'~|~\sigma'$ then $\Gamma ; \Sigma' \vdash t' : T$, and $\Sigma' \vdash \sigma'$ for some $\Sigma' \supseteq \Sigma$.

\item If $\Sigma \vdash (t, \sigma, Q)^h$ and $(t, \sigma, Q)^h \longrightarrow (t', \sigma', Q')^h$ then $\Sigma' \vdash (t', \sigma', Q')^h$ for some $\Sigma' \supseteq \Sigma$.

\item If $\Sigma \vdash H$ and $H \twoheadrightarrow H'$ then $\Sigma' \vdash H'$ for some $\Sigma' \supseteq \Sigma$.

\end{enumerate}

\end{thm}
\begin{proof}

Part 1: by induction on a derivation of $t~|~\sigma \rightarrow^h t'~|~\sigma'$ with case analysis of the last applied rule.

\begin{itemize}
\item Case R-AppAbs.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash t : T$
  \item $\Sigma \vdash \sigma$
  \item $t~|~\sigma \rightarrow^h t'~|~\sigma'$
  \end{enumerate}
% 2.
\item By R-AppAbs
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[((x : T') \Rightarrow t'')~v']$
  \item $t' = E[[x \mapsto v']t'']$
  \item $\sigma' = \sigma$
  \end{enumerate}
% 3.
\item By 1.a) and 2.a), $\Gamma ; \Sigma \vdash ((x : T') \Rightarrow t'')~v' : T''$.
% 4.
\item By 3. and T-App,
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash ((x : T') \Rightarrow t'') : T' \Rightarrow T''$
  \item $\Gamma ; \Sigma \vdash v' : T'$
  \end{enumerate}
% 5.
\item By 4.a) and T-Abs, $\Gamma , x : T' ; \Sigma \vdash t'' : T''$.
% 6.
\item By 4.b), 5., and Lemma~\ref{th:subst}, $\Gamma ; \Sigma \vdash [x \mapsto v']t'' : T''$.
% 7.
\item By 1.a), 2.a-b), 3., and 6., $\Gamma ; \Sigma \vdash t' : T$.
% 8.
\item 2.c) and 7. close this case.
\end{enumerate}

\item Cases R-ProjRcd, R-AppSpore, and R-Await follow analogously.

\item Case R-Map.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash t : T$
  \item $\Sigma \vdash \sigma$
  \item $t~|~\sigma \rightarrow^h t'~|~\sigma'$
  \end{enumerate}
% 2.
\item By R-Map
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{map}(r, p)]$
  \item $t' = E[r']$
  \item $r' = \text{Mapped}((h, i), r, p)$
  \item $i~\text{fresh}$
  \item $\sigma' = \sigma$
  \end{enumerate}
% 3.
\item By 1.a) and 2.a), $\Gamma ; \Sigma \vdash \texttt{map}(r, p) : \hat{T}$.
% 4.
\item By 3. and T-Map,
  \begin{enumerate}[label=(\alph*)]
  \item $\hat{T} = \texttt{SiloRef}[T']$
  \item $\Gamma ; \Sigma \vdash r : \texttt{SiloRef}[T'']$
  \item $\Gamma ; \Sigma \vdash p : (T'' \Rightarrow T' \{~\texttt{type}~\mathcal{C} = \seq{T}~\})$
  \end{enumerate}
% 5.
\item By 4.b) and T-SiloRef
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(id(r)) = T''$
  \item $\Sigma \vdash r$
  \end{enumerate}
% 6.
\item Define $\Sigma' := [(h, i) \mapsto T']\Sigma$.
% 7.
\item By 4.c), 5.a-b), 6., and WF-Ref1, $\Sigma' \vdash r'$.
% 8.
\item By 2.c), 6., 7., and T-SiloRef, $\Gamma ; \Sigma' \vdash r' : \texttt{SiloRef}[T']$.
% 9.
\item By 2.d), 3., 4.a), 6., and Lemma~\ref{lem:weakening-store-typing}, $\Gamma ; \Sigma' \vdash \texttt{map}(r, p) : \texttt{SiloRef}[T']$.
% 10.
\item By 1.a), 2.d), 6., and Lemma~\ref{lem:weakening-store-typing}, $\Gamma ; \Sigma' \vdash t : T$.
% 11.
\item By 2.a-b), 8., 9., 10., $\Gamma ; \Sigma' \vdash t' : T$.
% 12.
\item By 2.e) and 1.b), $\Sigma \vdash \sigma'$.
% 13.
\item By 6., $\Sigma' \supseteq \Sigma$.
% 14.
\item 11., 12., and 13. close this case.
\end{enumerate}

\item Cases R-FMap, R-Persist, and R-Unpersist follow analogously.
\end{itemize}

% 
Part 2: by induction on a derivation of $(t, \sigma, Q)^h \longrightarrow (t', \sigma', Q')^h$ with case analysis of the last applied rule.

\begin{itemize}

\item Case R-Seq. Then $t = E[s]$.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash (t, \sigma, Q)^h$
  \item $(t, \sigma, Q)^h \longrightarrow (t', \sigma', Q')^h$
  \end{enumerate}
% 2.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \sigma$
  \item $\Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 3.
\item By R-Seq
  \begin{enumerate}[label=(\alph*)]
  \item $E[s]~|~\sigma \rightarrow^h E[s']~|~\sigma'$
  \item $Q' = Q$
  \item $t' = E[s']$
  \end{enumerate}
% 4.
\item By 2.c), 3.a), and part 1
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma' \vdash E[s'] : T$
  \item $\Sigma' \vdash \sigma'$
  \item $\Sigma' \supseteq \Sigma$
  \end{enumerate}
% 5.
\item By 2.b), 4.c), and WF-Q1-3, $\Sigma' \vdash Q$.
% 6.
% \Sigma' \vdash \sigma'          // 4.b
% \Sigma' \vdash Q                // 5.
% t' = E[s']                      // 3.c
% \Gamma ; \Sigma' \vdash t' : T  // 4.a
\item By 4.b), 5., 3.c), 4.a), and WF-HostConfig, $\Sigma' \vdash (E[s'], \sigma', Q)^h$.
% 7.
\item 3.c), 4.c), and 6. close this case.
\end{enumerate}

\item Case R-SendLocal.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash (t, \sigma, Q)^h$
  \item $(t, \sigma, Q)^h \longrightarrow (t', \sigma', Q')^h$
  \end{enumerate}
% 2.
\item By R-SendLocal
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{send}(r)]$
  \item $t' = E[id(r)]$
  \item $Q' = Q \cdot {\Req h r {id(r)}}$
  \item $\sigma' = \sigma$
  \item $host(r) = h$
  \item $id(r) \notin dom(\sigma)$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \sigma$  % removed 3.b
  \item $\Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.a) and 3.c), $\Gamma ; \Sigma \vdash \texttt{send}(r) : T'$.
% 5.
\item By 4. and T-Send
  \begin{enumerate}[label=(\alph*)]
  \item $T' = \texttt{Future}[T'']$
  \item $\Gamma ; \Sigma \vdash r : \texttt{SiloRef}[T'']$
  \end{enumerate}
% 6.
\item By 5.b) and T-SiloRef
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(id(r)) = T''$
  \item $\Sigma \vdash r$
  \end{enumerate}
% \Sigma \vdash r
% 7.
\item By 6.b), 3.b), and WF-Q3, $\Sigma \vdash {\Req h r {id(r)}} :: Q$.
% 8.
\item By 7. and Lemma~\ref{lem:queue-ordering}, $\Sigma \vdash Q \cdot {\Req h r {id(r)}}$.
% 9.
\item By 6.a) and T-Ident, $\Gamma ; \Sigma \vdash id(r) : \texttt{Future}[T'']$.
% 10.
\item By 2.a-b), 3.c), 4., 5.a), and 9., $\Gamma ; \Sigma \vdash t' : T$.
% 11.
\item 3.a), 8., 10., and WF-HostConfig close this case.
\end{enumerate}

\item Case R-ProcQueueLocal.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash (t, \sigma, Q)^h$
  \item $(t, \sigma, Q)^h \longrightarrow (t', \sigma', Q')^h$
  \end{enumerate}
% 2.
\item By R-ProcQueueLocal
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota)]$
  \item $t' = t$
  \item $Q = m \cdot \hat{Q}$
  \item $process(h, m, \sigma) = (\sigma', Q', h)$
  \item $Q' = \hat{Q} ::: Q''$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \sigma$
  \item $\Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$ for some $\Gamma$
  \end{enumerate}
% 4.
\item By 2.c), 3.b), and WF-Q1-3, $\Sigma \vdash m \cdot \epsilon$.
% 5.
\item By 2.d), 3.a), 4., and Lemma~\ref{lem:process}
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma' \supseteq \Sigma$
  \item $\Sigma' \vdash \sigma'$
  \item $\Sigma' \vdash Q'$
  \end{enumerate}
% 6.
\item By 3.c), 5.a), and Lemma~\ref{lem:weakening-store-typing}, $\Gamma ; \Sigma' \vdash t : T$.
% 7.
\item 5.a-c), 6., and WF-HostConfig close this case.

\end{enumerate}
\end{itemize}

Part 3: by induction on a derivation of $H \twoheadrightarrow H'$ with case analysis of the last applied rule.

\begin{itemize}
\item Case R-Local.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Local
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (t, \sigma, Q)^h \} \cup H''$
  \item $H' = \{ (t', \sigma', Q')^h \} \cup H''$
  \item $(t, \sigma, Q)^h \longrightarrow (t', \sigma', Q')^h$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash (t, \sigma, Q)^h$ for some $\Sigma$
  \item $\vdash H''$
  \end{enumerate}
% 4.
\item By 2.c), 3.a), and part 2, $\Sigma' \vdash (t', \sigma', Q')^h$ and $\Sigma' \supseteq \Sigma$.
% 5.
\item By 2.b), 3.b), 4., and WF-Host2, $\vdash H'$.
\end{enumerate}

\item Case R-PopulateRemote.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\vdash H$
  % \Delta \vdash \{ (E[\texttt{populate}(\iota, v)], \mu, Q, S)^h \} \cup (\{ (t', \mu', Q', S')^{h'} \} \cup H'')
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-PopulateRemote
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (E[\texttt{populate}(h')], \sigma, Q)^h, (t', \sigma', Q')^{h'} \} \cup H''$
  \item $H' = \{ (E[\text{Mat}(\iota)], \sigma, Q)^h, (t', \sigma', Q' \cdot m)^{h'} \} \cup H''$
  \item $\iota     = (h, i)$
  \item $i~\text{fresh}$
  \item $m = {\PopReq h \iota}$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash (E[\texttt{populate}(h')], \sigma, Q)^h$ for some $\Sigma$
  \item $\vdash \{ (t', \sigma', Q')^{h'} \} \cup H''$
  \end{enumerate}
% 4.
\item By 3.b) and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma'' \vdash (t', \sigma', Q')^{h'}$ for some $\Sigma''$
  \item $\vdash H''$
  \end{enumerate}
% 5.
\item By 3.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \sigma$
  \item $\Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash E[\texttt{populate}(h')] : T$
  \end{enumerate}
% 6.
\item By 5.c) and T-Populate
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash \texttt{populate}(h') : \texttt{SiloRef}[\texttt{Unit}]$
  \item $\Gamma ; \Sigma \vdash h' : \texttt{Host}$
  \end{enumerate}
% 7.
\item Define $\Sigma' := [\iota \mapsto \texttt{Unit}]\Sigma$.
% 8.
\item By 7. and WF-Ref3, $\Sigma' \vdash \text{Mat}(\iota)$.
% 9.
\item By 7., 8., and T-SiloRef, $\Gamma ; \Sigma' \vdash \text{Mat}(\iota) : \texttt{SiloRef}[\texttt{Unit}]$.
% 10.
\item By 6.b) and T-Populate, $\Gamma ; \Sigma' \vdash \texttt{populate}(h') : \texttt{SiloRef}[\texttt{Unit}]$.
% 11.
\item By 5.c), 7., and Lemma~\ref{lem:weakening-store-typing}$\Gamma ; \Sigma' \vdash E[\texttt{populate}(h')] : T$.
% 12.
\item By 9., 10., and 11., $\Gamma ; \Sigma' \vdash E[\text{Mat}(\iota)] : T$.
% 13.
\item By 5.b), 7., and WF-Q1-3, $\Sigma' \vdash Q$.
% 14.
\item By 5.a), 13., 12., and WF-HostConfig, $\Sigma' \vdash (E[\text{Mat}(\iota)], \sigma, Q)^h$.
% 15.
\item By 4.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma'' \vdash \sigma'$
  \item $\Sigma'' \vdash Q'$
  \item $\Gamma' ; \Sigma'' \vdash t' : T''$
  \end{enumerate}
% 16.
\item By 15.a-c), and WF-HostConfig, $\Sigma'' \vdash (t', \sigma', Q')^{h'}$.
% 17.
\item By 2.b), 4.b), 14., 16., and WF-Host2, $\vdash H'$.
\end{enumerate}

\item Case R-SendRemote.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-SendRemote
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (E[\texttt{send}(r)], \sigma, Q)^h, (t', \sigma', Q')^{h'} \} \cup H''$
  \item $H' = \{ (E[id(r)], \sigma, Q)^h, (t', \sigma', Q' \cdot m)^{h'} \} \cup H''$
  \item $host(r) = h'$
  \item $h' \neq h$
  \item $m = {\Req h r {id(r)}}$  % 2.e)
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash (E[\texttt{send}(r)], \sigma, Q)^h$ for some $\Sigma$
  \item $\Sigma' \vdash (t', \sigma', Q')^{h'}$ for some $\Sigma'$
  \item $\vdash H''$
  \end{enumerate}
% 4.
\item By 3.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \sigma$
  \item $\Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash E[\texttt{send}(r)] : T$
  \end{enumerate}
% 5.
\item By 4.c), $\Gamma ; \Sigma \vdash \texttt{send}(r) : \hat{T}$.
% 6.
\item By 5. and T-Send
  \begin{enumerate}[label=(\alph*)]
  \item $\hat{T} = \texttt{Future}[T'']$
  \item $\Gamma ; \Sigma \vdash r : \texttt{SiloRef}[T'']$
  \end{enumerate}
% 7.
\item By 6.b) and T-SiloRef
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(id(r)) = T''$
  \item $\Sigma \vdash r$
  \end{enumerate}
% 8.
\item By 7.a) and T-Ident, $\Gamma ; \Sigma \vdash id(r) : \texttt{Future}[T'']$.
% 9.
\item By 4.c), 5., 6.a), and 8., $\Gamma ; \Sigma \vdash E[id(r)] : T$.
% 10.
\item By 4.a-b), 9., and WF-HostConfig, $\Sigma \vdash (E[id(r)], \sigma, Q)^h$.
% 11.
\item By 2.e), 7.b), and WF-Q1-3, $\Sigma \vdash m \cdot \epsilon$.
% 12. XXXXXXXXXXXXXXXXXXXXXXX
\item By 3.b) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma' \vdash \sigma'$
  \item $\Sigma' \vdash Q'$
  \item $\Gamma' ; \Sigma' \vdash t' : T'$
  \end{enumerate}
% 13.
% key: \Sigma' \vdash m \cdot \epsilon
% m = {\Req h r {id(r)}}  % 2.e)
% goal: \Sigma' \vdash r
% \Sigma' muss allen identifiers einen Typ geben, genauso wie \Sigma

% was wir ausschliessen muessen ist: \Sigma(\iota') \neq \Sigma'(\iota')


% 13.
\item By 11., 12.b), and Lemma~\ref{lem:queue-concat}, $\Sigma' \vdash Q' \cdot m$.
% 17.
\item By 15.a-b), 16., 15.d), and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q' \cdot m, S')^{h'}$.
% 18.
\item By 3.c), 13., 17., and WF-Host2, $\Delta \vdash H'$.
\end{enumerate}

\item Case R-Req1.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta \vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Req1
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H''$
  \item $H' = \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H''$
  \item $Q        = {\Req {h'} r \omega} :: Q''$
  \item $S(id(r)) = (\Val{v}, P)$
  \item $m        = {\Res \omega v P}$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q, S)^h$ for some $\Sigma$
  \item $\Delta ; \Sigma' \vdash (t', \mu', Q', S')^{h'}$ for some $\Sigma'$
  \item $\Delta \vdash H''$
  \end{enumerate}
% 4.
\item By 3.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma ; \Delta \vdash E[\texttt{await}(\iota)] : T$
  \end{enumerate}
% 5.
\item By 2.c), 4.c), and WF-Q1-4, $\Delta ; \Sigma \vdash Q''$.
% 6.
\item By 4.a-b), 5., 4.d), and WF-HostConfig, $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q'', S)^h$.
% 7.
\item By 3.b) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma' \vdash \mu'$
  \item $\Delta \vdash S'$
  \item $\Delta ; \Sigma' \vdash Q'$
  \item $\Gamma ; \Sigma' ; \Delta \vdash t' : T'$
  \end{enumerate}
% 8.
\item By 2.d), 4.b), and WF-SiloStore2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \hat{T}$
  \item $\emptyset ; \emptyset ; \Delta \vdash v : \hat{T}$
  \end{enumerate}
% 9.
\item By 2.c), 4.c), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \Delta(\omega)$
  \item $\Delta \vdash r$
  \end{enumerate}
% 10.
\item By 8.a-b), 9.a), WF-Q1, and WF-Q3, $\Delta ; \Sigma' \vdash m :: \epsilon$.
% 11.
\item By 7.c), 10., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma' \vdash Q' \cdot m$.
% 12.
\item By 7.a-b), 11., 7.d), and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q' \cdot m, S')^{h'}$.
% 13.
\item By 3.c), 6., 12., and WF-Host2, $\Delta \vdash H'$.
\end{enumerate}

\item Case R-Req2.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta \vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Req2
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H''$
  \item $H' = \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H''$
  \item $Q         = {\Req {h'} r \omega} :: Q''$
  \item $S(id(r))  = (\Fwd{r'}, P)$
  \item $S(id(r')) = (\Val{v}, P')$
  \item $m         = {\Res \omega v P}$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q, S)^h$ for some $\Sigma$
  \item $\Delta ; \Sigma' \vdash (t', \mu', Q', S')^{h'}$ for some $\Sigma'$
  \item $\Delta \vdash H''$
  \end{enumerate}
% 4.
\item By 3.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma ; \Delta \vdash E[\texttt{await}(\iota)] : T$
  \end{enumerate}
% 5.
\item By 2.c), 4.c), and WF-Q1-4, $\Delta ; \Sigma \vdash Q''$.
% 6.
\item By 4.a-b), 5., 4.d), and WF-HostConfig, $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q'', S)^h$.
% 7.
\item By 3.b) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma' \vdash \mu'$
  \item $\Delta \vdash S'$
  \item $\Delta ; \Sigma' \vdash Q'$
  \item $\Gamma' ; \Sigma' ; \Delta \vdash t' : T'$
  \end{enumerate}
% 8.
\item By 2.c), 4.c), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \Delta(\omega)$
  \item $\Delta \vdash r$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 9.
\item By 2.d), 4.b), and WF-SiloStore3
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r')) = \Delta(id(r))$
  \item $\Delta \vdash r'$
  \end{enumerate}
% 10.
\item By 2.e), 4.b), and WF-SiloStore2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r')) = \hat{T}$
  \item $\emptyset ; \emptyset ; \Delta \vdash v : \hat{T}$
  \end{enumerate}
% 11.
\item By 8.a), 9.a), and 10.a), $\Delta(\omega) = \hat{T}$.
% 12.
\item By 10.b), 11., WF-Q1, and WF-Q3, $\Delta ; \Sigma' \vdash {\Res \omega v P} :: \epsilon$.
% 13.
\item By 7.c), 12., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma' \vdash Q' \cdot m$.
% 14.
\item By 7.a-b), 13., 7.d), and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q' \cdot m, S')^{h'}$.
% 15.
\item By 3.c), 6., 14., and WF-Host2, $\Delta \vdash H'$.
\end{enumerate}

\item Case R-Req3.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta \vdash H$
  \item $H \twoheadrightarrow H'$
  \end{enumerate}
% 2.
\item By R-Req3
  \begin{enumerate}[label=(\alph*)]
  \item $H = \{ (E[\texttt{await}(\iota)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H''$
  \item $H' = \{ (E[\texttt{await}(\iota)], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H''$
  \item $Q         = {\Req {h''} r \omega} :: Q''$
  \item $S(id(r))  = (\Fwd{r'}, P)$
  \item $id(r') \notin dom(S)$
  \item $h'        = host(r')$
  \item $m         = {\Req {h''} {r'} \omega}$
  \end{enumerate}
% 3.
\item By 1.a), 2.a), and WF-Host2
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q, S)^h$ for some $\Sigma$
  \item $\Delta ; \Sigma' \vdash (t', \mu', Q', S')^{h'}$ for some $\Sigma'$
  \item $\Delta \vdash H''$
  \end{enumerate}
% 4.
\item By 3.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma ; \Delta \vdash E[\texttt{await}(\iota)] : T$
  \end{enumerate}
% 5.
\item By 2.c), 4.c), and WF-Q1-4, $\Delta ; \Sigma \vdash Q''$.
% 6.
\item By 4.a-b), 5., 4.d), and WF-HostConfig, $\Delta ; \Sigma \vdash (E[\texttt{await}(\iota)], \mu, Q'', S)^h$.
% 7.
\item By 3.b) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma' \vdash \mu'$
  \item $\Delta \vdash S'$
  \item $\Delta ; \Sigma' \vdash Q'$
  \item $\Gamma' ; \Sigma' ; \Delta \vdash t' : T'$
  \end{enumerate}
% 8.
\item By 2.c), 4.c), and WF-Q4
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r)) = \Delta(\omega)$
  \item $\Delta \vdash r$
  \item $\Delta ; \Sigma \vdash Q''$
  \end{enumerate}
% 9.
\item By 2.d), 4.b), and WF-SiloStore3
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta(id(r')) = \Delta(id(r))$
  \item $\Delta \vdash r'$
  \end{enumerate}
% 10.
\item By 8.a), 9.a-b), WF-Q1, and WF-Q4, $\Delta ; \Sigma' \vdash {\Req {h''} {r'} \omega} :: \epsilon$.
% 11.
\item By 7.c), 10., and Lemma~\ref{lem:queue-concat}, $\Delta ; \Sigma' \vdash Q' \cdot m$.
% 12.
\item By 7.a-b), 11., 7.d), and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q' \cdot m, S')^{h'}$.
% 13.
\item By 3.c), 6., 12., and WF-Host2, $\Delta \vdash H'$.
\end{enumerate}


\end{itemize}

\end{proof}

\newpage

\begin{thm}
\emph{(Lineage Replay Try 1)}\label{thm:replay-try1}

If
\begin{itemize}
\item $\omega = (h, 0)$, $r = \text{Mat}(\omega)$, and $dom(\Delta) = \{ \omega \}$
\item $S(\omega) = ({\Val v}, \emptyset)$ and $\Delta \vdash S$
\item $\Gamma; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T]$
\item $E[t] ~|~ \mu \rightarrow^{h'*} E[r'] ~|~ \mu$
%\item Let $r'$ be a lineage created starting from $r$.
\item $H := \{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], {\Req {h'} {r'} {\omega'}} :: \epsilon, S)^h\}$
\item $H \twoheadrightarrow^* \{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], {\Res {\omega'} {v'} \emptyset} :: \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], \epsilon, S')^h\}$
\end{itemize}
Then:
\begin{itemize}
\item $\omega'' = (h'', 0)$ and $dom(\Delta'') = \{ \omega'' \}$
\item $r'' = remap(r', [\omega \mapsto \omega''])$
\item $S''(\omega'') = ({\Val v}, \emptyset)$ and $\Delta'' \vdash S''$
\item $H'' := \{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], {\Req {h'} {r''} {\omega'}} :: \epsilon, S'')^{h''}\}$
\item $H'' \twoheadrightarrow^* \{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], {\Res {\omega'} {v'} \emptyset} :: \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], \epsilon, S''')^{h''}\}$

%\item sending ${\Req {h'} {r''} {\omega'}}$ to $h''$ yields ${\Res {\omega'} {v'} \emptyset}$ after a few steps
\end{itemize}
\end{thm}
\begin{proof}
%By induction on the structure of $r'$ with case analysis of the last lineage constructor used.
By induction on a derivation of $E[t] ~|~ \mu \rightarrow^{h'*} E[r'] ~|~ \mu$ with case analysis of the last applied reduction rule.
\begin{itemize}
\item Case R-Map.
\begin{enumerate}
% 1.
\item By the assumption
  \begin{enumerate}[label=(\alph*)]
  \item $r' = \text{Mapped}((h', i), r_p, p)$
  \item $i~\text{fresh}$
  \end{enumerate}
% 2.
\item By the IH
  \begin{enumerate}[label=(\alph*)]
  \item $\{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], {\Req {h'} {r_p} {\omega_p}} :: \epsilon, S)^h\} \twoheadrightarrow \{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], {\Res {\omega_p} {v_p} \emptyset} :: \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], \epsilon, S_p)^{h''}\}$
  \item $\{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], {\Req {h'} {r''_p} {\omega_p}} :: \epsilon, S'')^{h''}\} \twoheadrightarrow \{ (\texttt{await}(\iota'), [\iota' \mapsto \text{None}], {\Res {\omega_p} {v_p} \emptyset} :: \epsilon, \epsilon)^{h'}, (\texttt{await}(\iota), [\iota \mapsto \text{None}], \epsilon, S'''_p)^{h''}\}$ for remapped $r''_p$
  \end{enumerate}

\end{enumerate}

\end{itemize}
\end{proof}

\begin{thm}
\emph{(Lineage Replay Scratch)}\label{thm:replay2}

$m(h) = h'$
$m \in Host \rightarrow Host$

$max(h) = i_h$

%$remap(r, m) := begin{cases}
%  Mat((m(h), 0))                   & r = Mat((h, 0)) \\
%  Mapped(\omega, remap(r', m), p)  & r = Mapped(\omega, r', p) \\
%\end{cases}
%$

$r' = remap(r, m)$

Simple case.
Start:
\begin{itemize}
\item $r = \text{Mat}(\omega)$
\item $\omega = (h, 0)$
\item $\Delta \vdash r$
\item $dom(\Delta) = \{ \omega \}$
\item $S(\omega) = ({\Val v}, \emptyset)$
\item $\Delta \vdash S$
\item Consider lineage $\hat{r}$ created starting with just $r$.
\item $\Gamma; \Sigma ; \Delta \vdash t : \texttt{SiloRef}[T']$
\item $E[t] ~|~ \mu \rightarrow^{\hat{h}*} E[\hat{r}] ~|~ \mu$
\item send $Req(\hat{h}, \hat{r}, \hat{\omega})$ to $h$
\item then $Res$ will contain value $v'$.

\item $(E[await(send(\hat{r}))], \mu, Q, S)^{\hat{h}} \cup H \twoheadrightarrow^* (E[v'], \mu', Q', S')^{\hat{h}}$

\item $v' = materialize(\hat{r})$
\item Client $\hat{h}$ requests materialization of $\hat{r}$
\item Materialization yields value $v'$
\end{itemize}

Next:
\begin{itemize}
\item $r' = \text{Mat}(\omega')$
\item $\omega' = (h', i')$
\item $\Delta \vdash r'$
\item $S'(\omega') = ({\Val v}, \emptyset)$
\item Client baut lineage $\hat{r'}$
\item Client $\hat{h}$ request materialization of $\hat{r'}$
\item Materialization yields value $v'$
\end{itemize}



\begin{itemize}
\item $\forall r_i \in \seq{r}.~r_i = \text{Mat}(\omega_i)$
\item $\Delta \vdash \seq{r}$
\end{itemize}


\end{thm}

\begin{thm}
\emph{(Lineage Replay)}\label{thm:replay}

If
\begin{itemize}
\item $\emptyset ; \emptyset ; \Delta \vdash t : \texttt{SiloRef}[T]$
\item $H_1 := \{ (E_1[send(t)], \mu_1, Q_1, S_1)^h \} \cup H_2$
\item $\vdash H_1$
\item $H_1 \twoheadrightarrow^* \{ (E_1[\iota], \mu_2, Q_2, S_2)^h \} \cup H_3$
\item $\mu_2(\iota) = \text{Some}(v)$
\end{itemize}
then:
\begin{itemize}
\item $H_4 := \{ (E_2[send(t)], \mu_3, Q_3, S_3)^{h'} \} \cup H_5$
\item $\vdash H_4$
\item $H_4 \twoheadrightarrow^* \{ (E_2[\iota], \mu_4, Q_4, S_4)^{h'} \} \cup H_6$
\item $\mu_4(\iota) = \text{Some}(v)$
\end{itemize}

\end{thm}
\begin{proof}
\end{proof}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fault handling.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO Describe how to utilize the herein presented foundation
%      to realize fault tolerance. 

%\begin{figure}[ht!]
%\centering
%\begin{mathpar}
%
%\inferrule[\textsc{RF-Send}] { 
%  host(r) = h'      \quad
%  h' \neq h         \quad
%  \text{failed}(h') \\
%  i~\text{fresh}    \quad
%  \iota = (h, i)    \quad
%  S'' = S + (\iota \mapsto \bot)
%} { 
%  \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \twoheadrightarrow
%  \{ (R[\iota], E, S'')^h \} \cup H
%}
%
%\inferrule[\textsc{RF-Req4}]
%{ 
%  E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
%  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
%}
%{ 
%  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
%}
%
%\inferrule[\textsc{RF-Req5}]
%{ 
%  E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
%  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
%  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
%}
%{ 
%  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\inferrule[\textsc{RF-ReqF}]
%{ 
%  E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
%  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
%}
%{ 
%  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
%}
%
%\end{mathpar}
%\caption{Fault handling.}
%\end{figure}

%\begin{description}[font=\normalfont\itshape\space]
%\item[\textsc{RF-Send}] ...
%
%\item[\textsc{RF-Req4}] XXX Why $4$?
%
%\item[\textsc{RF-Req5}] ...
%
%\item[\textsc{R-ReqF}] ...
%\end{description}

\end{document}
