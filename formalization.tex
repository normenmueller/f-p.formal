\documentclass{article}
\usepackage{todonotes}
\usepackage{lscape}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bcprules}
\usepackage{mathpartir}
\usepackage{mdframed}

%% Math
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]
\newtheorem{thm}{Theorem}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{defn}{Definition}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{prop}{Property}[section]

%% Spacing
\newcommand{\gap}{\quad\quad}

%% Arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

%% Syntax
% Member sequences
\newcommand{\seq}[1]{\overline{#1}}

\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

%% Calculus abbreviations
\newcommand{\None}{\text{None}}
\newcommand{\Some}[1]{\text{Some}(#1)}
\newcommand{\Val}[1]{\text{Val}(#1)}
\newcommand{\Fwd}[1]{\text{Fwd}(#1)}
\newcommand{\Req}[3]{\text{Req}_s(#1, #2, #3)}
\newcommand{\Res}[3]{\text{Res}_s(#1, #2, #3)}
\newcommand{\ReqF}[2]{\text{Req}_{\iota}(#1, #2)}
\newcommand{\ReqE}[3]{\text{Req}_f(#1, #2, #3)}
\newcommand{\Per}[3]{\text{Persist}(#1, #2, #3)}
\newcommand{\consume}[3]{\text{consume}(#1, #2, #3)}

\begin{document}

\todo[inline]{Conclude Part 2 and 3 of Subject Reduction}
\todo[inline]{Fix fault tolerance}
\todo[inline]{Related work}
\todo[inline]{Verbalize formalization}
\todo[inline]{Fix memory handling\\[2ex] IDEA: provide explicit operators for memory handling; a subsequent static analysis would augment those explicit declaration with further usage of those explicit operators; i.e., a static analysis yields a composition of those memory handling primitives\\[2ex] First approach: incorporate reference counting}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                       & \mbox{{\it{terms:}}} \\                                
\gap \:\:\:\:  x                                                            & \mbox{variable} \\                                
\gap ~|~  (x: T) \Rightarrow t                                              & \mbox{abstraction} \\                                
\gap ~|~  t~t                                                               & \mbox{application} \\                                
%\gap ~|~  \texttt{let}~x = t~\texttt{in}~t                                  & \mbox{let binding} \\                                
\gap ~|~  \{ \seq{l = t} \}                                                 & \mbox{record construction} \\                                
\gap ~|~  t.l                                                               & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}       & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(t)                                                 & \mbox{spawn host} \\
\gap ~|~  \texttt{populate}(t, t)                                           & \mbox{populate silo} \\
\gap ~|~  \texttt{map}(t, t[, t])                                           & \mbox{map} \\                          
\gap ~|~  \texttt{flatMap}(t, t[, t])                                       & \mbox{flatMap} \\                          
\gap ~|~  \texttt{persist}(t)                                               & \mbox{persist} \\
\gap ~|~  \texttt{send}(t)                                                  & \mbox{send} \\           % send  :: Ref a -> Fut a
\gap ~|~  \texttt{await}(t)                                                 & \mbox{await future} \\   % await :: Fut a -> a                        
\gap ~|~  \iota                                                                 & \mbox{location} \\                          
                                                                            & \\                                
v ::=                                                                       & \mbox{{\it{values:}}} \\                                
\gap \:\:\:\: (x: T) \Rightarrow t                                          & \mbox{abstraction value} \\                                
\gap ~|~  \{ \seq{l = v} \}                                                 & \mbox{record value} \\                                
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}                                                                 & \mbox{spore value} \\                                
\gap ~|~  \iota                                                             & \mbox{location} \\
                                                                            & \\   
T ::=                                                                       & \mbox{{\it{types:}}} \\                          
\gap \:\:\:\: T \Rightarrow T                                               & \mbox{function type} \\                          
\gap ~|~  \{ \seq{l : T} \}                                                 & \mbox{record type} \\                          
\gap ~|~  \mathcal{S}                                                       & \mbox{} \\
\gap ~|~  \texttt{Host}                                                     & \mbox{host type} \\
\gap ~|~  \texttt{SiloRef}[T]                                               & \mbox{silo reference type} \\
\gap ~|~  \texttt{Future}[T]                                                & \mbox{future type} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}                    & \mbox{abstract spore type} \\
\ea$

\caption{Abstract syntax of core language.}
\end{figure}

Classification of $r$ and $\iota$ is specified at Figure~\ref{fig:elems-opsem}.

$\iota$ .... decentralized identifier

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Elements of the operational model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
r ::=                                                  & \mbox{{\it{silo reference values:}}} \\
\gap \:\:\:\: \text{Mat}(\omega)                       & \mbox{materialized} \\    
\gap ~|~  \text{Mapped}(\omega, r, p, opt_f)           & \mbox{lineage with \texttt{map}} \\    
\gap ~|~  \text{FMapped}(\omega, r, p, opt_f)          & \mbox{lineage with \texttt{flatMap}} \\   
\gap ~|~  \text{Persist}(\omega, r)                    & \mbox{lineage with \texttt{persist}} \\
                                                       & \\   
\omega  ::= (h,i) \quad \text{where}~i \in \mathbb{N}  & \mbox{decentralized identifier} \\
                                                       & \\
Q      ::=                                             & \mbox{{\it{message queue values:}}} \\
\gap \:\:\:\: \epsilon                                 & \mbox{empty queue} \\
\gap ~|~    {\Res \omega v P} :: Q                     & \mbox{response (silo)} \\
\gap ~|~    {\Req h r \omega} :: Q                     & \mbox{request (silo)}  \\
\gap ~|~    {\ReqF \iota \omega} :: Q                  & \mbox{request (future)}  \\
\gap ~|~    {\ReqE h r \omega} :: Q                    & \mbox{request (fault)} \\
\ea$

\caption{Elements of the operational model.}
\label{fig:elems-opsem}

\end{figure}

\begin{description}
\item[$\iota$] Encodes latency, in terms of completion of a materialization of a silo, as well as the location of the either already materialized or to be materialized silo. The location, in turn, serves as the unique, decentralized identifier of the respective silo reference.

% << Network communication >>
%
%               <<CODE>>                                                    << LINEAGE>>                             <<SILO>>
% Host: h0    
% val r0: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))                   ~~>        h1 
% r0.id    == (h1,0)                                                              ^
% host(r0) == h1                                                                  |
%                                                                                 |
% << No network communication >>                                                  |
%                                                                                 |
% val r1: SiloRef[List[Vehicle]] = r0 map sp0                           ~~>   Mapped((h0,0), r0, sp0, None) ~~>        h1
% r1.id    == (h0,0)      
% host(r1) == h1      
%   
% << Network communication >>   
%   
% val r2: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))
% r2.id    == (h1,0)
% host(r2) == h1 
% r2       == r0

\item[$Mat(\iota)$] A silo reference where the referenced silo is already materialized, or is to be materialized, at location $\iota$.
% (h,i) is the decentralized identifier of the materialized silo hosted at h. In this case \iota gives us the location of the materialized silo.

\item[$Mapped(\iota, r, p, opt_f)$] Map spore $p$ over the silo which is referenced by $r$. The resulting silo of this transformation is referenced by the new silo reference identified by $\iota$. In case of failure at the host of the referenced silo apply $opt_f$.  

%      r     --> s  @ host(r)
%                ^
%                |
%                | Mapped
%                |
%      r'    --> s' @ host(r) = host(r')
%
% Decentralized identifier of r' is \iota.

\item[$FMapped(\iota, r, p, opt_f)$] Analogous to $Mapped$.
\end{description}

A lineage build up by those silo reference values can be considered as a {\emph{data flow graph}}\cite{???}. %Note, verbalisation is imperative to emphasize lazy creation. 

\begin{description}
\item[${\Res \iota v P}$] A response message which instructs the receiver to complete future $\iota$ with value $v$. % TODO: explain `P`.

\item[${\Req h r \iota}$] A request message from $h$ which instructs the receiver to respond with the materialized silo referenced by $r$; $\iota$ uniquely identifies the response in terms of the future $\iota$ to be completed by the sender of the request.

\item[$ReqF(h, r, \iota)$] Analogous to $Req$.
\end{description}

In the following we introduce a function to backtrack the host of a referenced silo.

\begin{defn}[Host]
  The function application $host(r)$ obtains the host of the silo referenced by $r$; $host$ is defined as follows:
  
  $host(r) := \begin{cases}
    h        & \text{if } r = Mat((h, i)) \\
    host(r') & \text{if } r = Mapped(\_, r', \_, \_) \\
    host(r') & \text{if } r = FMapped(\_, r', \_, \_) \\
    host(r') & \text{if } r = Persist(\_, r', \_) \\
    \end{cases}$
\end{defn}

Analogous to~\cite{TAPL}, we introduce the notion of an evaluation context and write $E[t]$ for the ordinary term obtained by replacing the hole in $E$ with $t$. Evaluation contexts capture the notion of the ``next subterm to be reduced.''

\begin{defn}[Evaluation Context]
  The set of evaluation contexts is defined as follows:
  
 $\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
%\gap ~|~  \texttt{let}~x = E~\texttt{in}~t                                                                & \mbox{let (bind)} \\
%\gap ~|~  \texttt{let}~x = v~\texttt{in}~E                                                                & \mbox{let (body)} \\
\gap ~|~  \{ \seq{l = v} ; l_i = E ; \seq{l' = t} \}                                                      & \mbox{record} \\
\gap ~|~  E.l                                                                                             & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(E)                                                                               & \mbox{spawn} \\
\gap ~|~  \texttt{populate}(E, t)                                                                         & \mbox{populate (host)} \\
\gap ~|~  \texttt{populate}(v, E)                                                                         & \mbox{populate (spore)} \\
\gap ~|~  \texttt{map}(E, t[, t])                                                                         & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E[, t])                                                                         & \mbox{map (fun)} \\
\gap ~|~  \texttt{map}(v, v', E)                                                                          & \mbox{map (err)} \\
\gap ~|~  \texttt{flatMap}(E, t[, t])                                                                     & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E[, t])                                                                     & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{flatMap}(v, v', E)                                                                      & \mbox{flatMap (err)} \\
\gap ~|~  \texttt{persist}(E)                                                                             & \mbox{persist} \\
\gap ~|~  \texttt{send}(E)                                                                                & \mbox{send} \\
\gap ~|~  \texttt{await}(E)                                                                               & \mbox{await} \\
\ea$ 
\end{defn}

\begin{defn}[Silo reference identifier]
    $id(r) := \begin{cases}
    \omega  & \text{if } r = Mat(\omega) \\
    \omega  & \text{if } r = Mapped(\omega, r', \_, \_) \\
    \omega  & \text{if } r = FMapped(\omega, r', \_, \_) \\
    \omega  & \text{if } r = Persist(\omega, r', \_) \\
    \end{cases}$
\end{defn}

\begin{defn}[Silo reference parent]
    $parent(r) := \begin{cases}
    \None     & \text{if } r = Mat(\_) \\
    \Some{r'} & \text{if } r = Mapped(\_, r', \_, \_) \\
    \Some{r'} & \text{if } r = FMapped(\_, r', \_, \_) \\
    \Some{r'} & \text{if } r = Persist(\_, r', \_) \\
    \end{cases}$
\end{defn}

\begin{defn}[Consume silo]
Consume silo $\omega$ with persist set $P$ in silo store $S$ \\
  $consume(\omega, P, S) := \begin{cases}
  S - \omega & \text{if } P = \emptyset \\
  S          & \text{otherwise} \\
  \end{cases}$
\end{defn}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Lambda reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-AppAbs}] {} {
  E[((x: T) \Rightarrow t)~v']~|~\mu
  \rightarrow^h
  E[[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-ProjRcd}] {} {
  E[\{\seq{l_i = v_i^{i \in 1..n}}\}.l_j]~|~\mu
  \rightarrow^h
  E[v_j]~|~\mu
}

\inferrule[\textsc{R-AppSpore}] {} {
  E[(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~v']~|~\mu
  \rightarrow^h
  E[\seq{[x \mapsto v]}[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-Await}] {
  \mu(\iota) = \text{Some}(v)
} {
  E[\texttt{await}(\iota)]~|~\mu
  \rightarrow^h
  E[v]~|~\mu
}

\inferrule[\textsc{R-Map}] { 
  \mu(\iota) = r                                \quad
  r' = \text{Mapped}((h, i), r, p, \text{None}) \quad
  i~\text{fresh}                                \quad
  \mu' = \mu + (\iota' \mapsto r')              \quad
  \iota'~\text{fresh}
} { 
  E[\texttt{map}(\iota, p)]~|~\mu
  \rightarrow^h
  E[\iota']~|~\mu'
}

\inferrule[\textsc{R-FMap}] { 
  \mu(\iota) = r                                 \quad
  r' = \text{FMapped}((h, i), r, p, \text{None}) \quad
  i~\text{fresh}                                 \quad
  \mu' = \mu + (\iota' \mapsto r')               \quad
  \iota'~\text{fresh}
} {
  E[\texttt{flatMap}(\iota, p)]~|~\mu
  \rightarrow^h
  E[\iota']~|~\mu'
}

\inferrule[\textsc{R-Persist}] { 
  \mu(\iota) = r                                   \quad
  r' = \text{Persist}((h, i), r, \cdot \cup \cdot) \quad
  i~\text{fresh}                                   \quad
  \mu' = \mu + (\iota' \mapsto r')                 \quad
  \iota'~\text{fresh}
} { 
  E[\texttt{persist}(\iota)]~|~\mu
  \rightarrow^h
  E[\iota']~|~\mu'
}

\inferrule[\textsc{R-Unpersist}] { 
  \mu(\iota) = r                                        \quad
  r' = \text{Persist}((h, i), r, \cdot \setminus \cdot) \quad
  i~\text{fresh}                                        \quad
  \mu' = \mu + (\iota' \mapsto r')                      \quad
  \iota'~\text{fresh}
} { 
  E[\texttt{unpersist}(\iota)]~|~\mu
  \rightarrow^h
  E[\iota']~|~\mu'
}

\end{mathpar}
\caption{Sequential reduction.}
\end{figure}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define silo store

We write $S' = S + (\iota \mapsto (B, P))$ to express the fact that $S'$ maps $\iota$ to a pair $(B, P)$ and otherwise agrees with $S$. $B$ is a binding of the form $\Val{v}$ or $\Fwd{r}$; the former contains a materialized value $v$, the latter forwards to silo reference $r$, such that $\iota$ is effectively bound to the same value as the identifier of $r$. $P \subset Hosts$ is a set of hosts which have persisted the silo identified by $\iota$. We write $S(\iota) = \text{Some}(B, P)$ to express the fact that $S$ maps $\iota$ to $(B, P)$. We write $S(\iota) = \text{None}$ if $S$ does not have a mapping for $\iota$.

Our formalization simplifies the computation model with respect to materialized silos. In case of a silo reference of the form $Mat((h, i))$ we assume that there is a mapping in the corresponding silo store $S$, such that $S((h, i)) = \text{Some}(\Val{v}, \{ h \})$ for some value $v$.

%% r = Mat((h,i)) = init(hdfs://...)
%% r.unpersist

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-Seq}] { 
  E[t]~|~\mu \rightarrow^h E[t']~|~\mu'
} {
  (E[t], \mu, Q, S)^h
  \longrightarrow
  (E[t'], \mu', Q, S)^h
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\inferrule[\textsc{R-Send1Local}] {
  \mu(\iota) = r                            \quad
  host(r) = h                               \quad
  S(id(r)) = \text{Some}(\Val{v}, P)        \\
  \iota'~\text{fresh}                       \quad
  \mu' = [\iota' \mapsto \text{Some}(v)]\mu
} {
  (E[\texttt{send}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\iota'], \mu', Q, S)^h
}

\inferrule[\textsc{R-Send2Local}] {
  \mu(\iota) = r                         \quad
  host(r)    = h                         \quad
  S(id(r)) \neq \text{Some}(\Val{v}, P)  \\
  \iota'~\text{fresh}                    \quad
  \mu' = [\iota' \mapsto \text{None}]\mu
} {
  (E[\texttt{send}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\iota'], \mu', Q \cdot {\Req h r {id(r)}} \cdot {\ReqF {\iota'} {id(r)}}, S)^h
}


\inferrule[\textsc{R-ReqF1}] {
  Q         = {\ReqF \iota \omega} :: Q' \quad
  S(\omega) = \text{Some}(\Val{v}, P)    \\
  S'        = {\consume \omega P S}      \quad
  \mu'      = [\iota \mapsto \text{Some}(v)]\mu
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu', Q', S')^h
}

\inferrule[\textsc{R-ReqF2}] {
  Q           = {\ReqF \iota \omega} :: Q'    \quad
  S(\omega) \neq \text{Some}(\Val{v}, P)
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu, Q' \cdot {\ReqF \iota \omega}, S)^h
}

\end{mathpar}
\caption{Deterministic reduction (future).}
\end{figure}

% Note: design approach is to *not* replace Fwds in the silo store, since
% it would require copying data. Instead, we leverage the flexibility of
% Req messages to correctly forward requests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Important that Res message contains correct P, since R-Res
% updates silo store.
% Goal: theorem which states that persist sets are "correct".
% We don't lose hosts from persist sets.

\begin{figure}[ht!]
\centering

\begin{mathpar}

\inferrule[\textsc{R-Res}] {
  Q  = {\Res \omega v P} :: Q'          \\
  S' = S + (\omega \mapsto (\Val{v}, P))
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q', S')^h
}

\inferrule[\textsc{R-Req1Local}] {
  Q         = {\Req h r \omega} :: Q'        \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)       \quad %
  S(id(r')) = \text{Some}(\Val{v}, P')       \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v P}, S')^h
}

\inferrule[\textsc{R-Req2Local}] {
  Q         = {\Req h r \omega} :: Q'              \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)             \quad %
  S(id(r')) \neq \text{Some}(\Val{v}, P')          \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} \omega}, S')^h
}

\inferrule[\textsc{R-ReqMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'                    \quad %
  r          = \text{Mapped}(\omega', r', p, \text{None})    \quad %
  S(id(r'))  = \text{Some}(\Val{v}, P)                       \\
  v'         = p(v)                                          \quad %
  S'         = S  + (\omega' \mapsto (\Val{v'}, \emptyset))  \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} r \omega}, S'')^h
}

\inferrule[\textsc{R-ReqFMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'                   \quad %
  r          = \text{FMapped}(\omega', r', p, \text{None})  \quad %
  S(id(r'))  = \text{Some}(\Val{v}, P)                     \\
  r''        = p(v)                                        \quad %
  S'         = S + (\omega' \mapsto (\Fwd{r''}, \emptyset)) \quad
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} {r''} \omega}, S'')^h
}

\inferrule[\textsc{R-ReqPersistLocal}] {
  Q          = {\Req h r \omega} :: Q'                      \quad %
  r          = {\Per {\omega'} {r'} \star}                  \quad %
  \omega'    = (h, i)                                      \quad %
  S(id(r'))  = \text{Some}(\Val{v}, P)                     \\
  P'         = P \star \{h\}                               \quad %
  S'         = S  + (\omega' \mapsto (\Val{v}, P'))         \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q,  S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v {P'}}, S'')^h
}

\inferrule[\textsc{R-ReqParentLocal}] {
  Q               = {\Req {h'} r \omega} :: Q'  \quad %
  \text{Some}(r') = parent(r)                  \quad %
  S(id(r'))     \neq \text{Some}(\Val{v}, P)   \\
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} {id(r')}} \cdot {\Req {h'} r \omega}, S)^h
}

\end{mathpar}
\caption{Deterministic reduction (silo).}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Map}] ...

\item[\textsc{R-FMap}] ...

\item[\textsc{R-Await}] ...

\item[\textsc{R-Res}] ...

\item[\textsc{R-ReqLocal}] ...
\end{description}

Note, the reduction rules \textsc{R-Map} and \textsc{R-FMap} do not involve communication with other hosts.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Non-deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% (t, Q, S)^h_c -> <crash>
% H' = { h' | h \in H \land h' = crashed(h_c, h) }
% --------------------------------------------------
%    { (t, Q, S)^h_c } \cup H -->> H'
%
%
% update silo store to reflect crash of h_c
% S' = { id -> (v, C') | id -> (v, C) \in S \land C' = C[h_c -> 0] }
% ---------------------------------------------------------------------
%    crashed(h_c, (t, Q, S)^h) = (t, Q, S')^h
%
%
%   S(id) =  Some(v)       |  None
%
%   S(id) = (Some(v), cnt) | (None, cnt)
%
%   S(id) = (Some(v), [h -> 3, h' -> 2]) | (None, ...)
%
%   S(id) = (Some(v), C)   | (None, C)


\begin{figure}[ht!]
\begin{mathpar}
\inferrule[\textsc{R-Determ}] {
  (t, \mu, Q, S)^h \rightarrow (t', \mu', Q', S')^h
} { 
  \{ (t, \mu, Q, S)^h \} \cup H
  \twoheadrightarrow
  \{ (t', \mu', Q', S')^h \} \cup H
}

\inferrule[\textsc{R-Spawn}] { 
  h'~\text{fresh}
} {
  \{ (E[\texttt{spawn}(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})], \mu, Q, S)^h \} \cup H
  \\ \twoheadrightarrow
  \{ (E[h'], \mu, Q, S)^h, ((\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~\{\}, \epsilon, \epsilon, \epsilon)^{h'} \} \cup H
}

% TODO send spore instead of a value `v`
\inferrule[\textsc{R-Populate}] { 
  S''    = S' + (\omega \mapsto v)      \quad
  \omega = (h', i) \quad i~\text{fresh} \quad
  \mu'' = [\iota \mapsto \text{Mat}(\omega)]\mu \quad \iota~\text{fresh}
} {
  \{ (E[\texttt{populate}(h', v)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\iota], \mu'', Q, S)^h, (t', \mu', Q', S'')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req1}] { 
  Q        = {\Req {h'} r \iota} :: Q''  \quad
  S(id(r)) = \text{Some}(\Val{v}, P)     \quad
  m        = {\Res \iota v P}
} { 
  \{ (E[\texttt{await}(\iota')], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota')], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

% Rules that send Req:
% R-Send: true (append)
% (R-Req2Map: true (prepend))
% R-Req2Fwd: true (prepend)
% 
% if a rule sends Req(h, r) to h', is it true that host(r) == h'?
% XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\inferrule[\textsc{R-Req2}] {
  Q         = {\Req {h'} r \iota} :: Q''           \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)             \\ %
  S(id(r')) = \text{Some}(\Val{v}, P')             \quad %
  m        = {\Res \iota v P}
} {
  \{ (E[\texttt{await}(\iota')], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota')], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

% 1. Angenommen Host h hat einen \Fwd{r'}, dann wissen wir nicht, 
%    auf welchem Host r' liegt. Das war der eigentliche Grund, Fwd
%    einzufuehren, weil dann ein flatMap keine Daten transferieren muss.
%    D.h. wir wollen zulassen, dass eine Referenz in einem Fwd auf
%    einem beliebigen Host liegen kann.
% Jetzt kann es sein, dass ich auf Host h ein r = r0.flatMap(p) mache.
% diese Referenz r kann ich an einen anderen Host h' geben.
% Jetzt macht Host h' ein r.send(). D.h., h' schickt einen Req(h', r) an h.
% Jetzt sagt Host h: S(id(r)) = Fwd(r'), und r' kann auch auf Host h' sein
% (da Host von r' beliebig wie oben erwaehnt).
% Und in diesem Fall gilt, dass host(r') = h' ist, und daher Host h
% einen Req(h', r' r) an h'' = h' sendet. Das hat zur Folge, das Host h'
% jetzt einen Req(h', r', r) bearbeiten muss. Daher muessen auch die lokalen
% Regeln mit zwei unterschiedlichen Referenzen umgehen koennen, weil
% r definitiv ungleich r' ist.
\inferrule[\textsc{R-Req3}] {
  Q         = {\Req {h''} r \iota} :: Q''            \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)               \\ %
  S(id(r')) \neq \text{Some}(\Val{v}, P')            \quad %
  h'        = host(r')                               \quad %
  m         = {\Req {h''} {r'} \iota}
} {
  \{ (E[\texttt{await}(\iota')], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota')], \mu, Q'', S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

\inferrule[\textsc{R-Send}] {
  host(r) = h'                          \quad
  h' \neq h                             \quad
  m = {\Req h r {id(r)}}                \quad
  \iota~\text{fresh}                    \quad
  \mu'' = [\iota \mapsto \text{None}]\mu
} {
  \{ (E[\texttt{send}(r)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\iota], \mu'', Q, S)^h, (t', \mu', Q' \cdot m, S')^{h'} \} \cup H
}

\end{mathpar}
\caption{Non-deterministic reduction.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Send}] ...

\item[\textsc{R-Req1}] ...

\item[\textsc{R-Req2}] ...

\item[\textsc{R-Req3}] ...

\item[\textsc{R-Req4}] ...
\end{description}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Type assignment.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}
% variable
\inferrule[\textsc{T-Var}] {
  x : T \in \Gamma
} { 
  \Gamma ; \Sigma \vdash x : T
}

\inferrule[\textsc{T-Loc}] {
  \Sigma(\iota) : T
} {
  \Gamma ; \Sigma \vdash \iota : T
}

% abstraction
\inferrule[\textsc{T-Abs}] {
  \Gamma, x : T ; \Sigma \vdash t : T'
} { 
  \Gamma ; \Sigma \vdash ((x: T) \Rightarrow t) : T \Rightarrow T'
}

% application
\inferrule[\textsc{T-App}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T' \quad \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

% record
\inferrule[\textsc{T-Record}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T}
} {
  \Gamma ; \Sigma \vdash \{ \seq{l = t} \} : \{ \seq{l : T} \}
}

% selection
\inferrule[\textsc{T-Select}] {
  \Gamma ; \Sigma \vdash t : \{ \seq{l : T} \}
} {
  \Gamma ; \Sigma \vdash t.l_i : T_i
}

% spore
\inferrule[\textsc{T-Spore}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T} \quad \seq{x : T}, x : T ; \Sigma \vdash t : T'
} { 
  \Gamma ; \Sigma \vdash (\texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}) : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}
}

% spawn
\inferrule[\textsc{T-Spawn}] {
  \Gamma ; \Sigma \vdash t : (\{\} \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{spawn}(t) : \texttt{Host}
}

% populate
% TODO make async (Future[SiloRef[T]]); cf. R-Populate
\inferrule[\textsc{T-Populate}] {
  \Gamma ; \Sigma \vdash t : \texttt{Host} \quad \Gamma ; \Sigma \vdash t' : T
} {
  \Gamma ; \Sigma \vdash \texttt{populate}(t, t') : \texttt{SiloRef}[T]
}

% map
\inferrule[\textsc{T-Map}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad \Gamma ; \Sigma \vdash t' : (T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{map}(t, t') : \texttt{SiloRef}[T']
}

% flatMap
\inferrule[\textsc{T-FMap}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad \Gamma ; \Sigma \vdash t' : (T \Rightarrow \texttt{SiloRef}[T']~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{flatMap}(t, t') : \texttt{SiloRef}[T']
}

% persist
\inferrule[\textsc{T-Persist}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{persist}(t) : \texttt{SiloRef}[T]
}

% send
\inferrule[\textsc{T-Send}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{send}(t) : \texttt{Future}[T]
}

% await
\inferrule[\textsc{T-Await}] {
  \Gamma ; \Sigma \vdash t : \texttt{Future}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{await}(t) : T
}

\end{mathpar}
\caption{Type assignment.}
\end{figure}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Subject reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}

\inferrule[\textsc{WF-Store1}] {} {
  \emptyset \vdash \emptyset
}

\inferrule[\textsc{WF-Store2}] {
  \Sigma \vdash \mu
} {
  [\iota \mapsto T]\Sigma \vdash [\iota \mapsto v]\mu
}

\inferrule[\textsc{WF-SiloStore1}] {} {
  \Delta \vdash \emptyset
}

\inferrule[\textsc{WF-SiloStore2}] {
  \omega \in dom(\Delta) \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto v]S
}

\inferrule[\textsc{WF-SiloStore3}] {
  \Delta(id(r)) = \Delta(\omega)      \quad
  \Delta \vdash S
} {
  \Delta \vdash [\omega \mapsto \text{Some}(\text{Fwd}(r), P)]S
}

\inferrule[\textsc{WF-Env1}] {} {
  \emptyset ; \emptyset \vdash \emptyset
}

\inferrule[\textsc{WF-Env2}] {
  \Sigma(\iota) = \texttt{SiloRef}[T]  \quad
  \Delta(id(r)) = T                    \quad
  \Delta ; \Sigma \vdash \mu
} {
  \Delta ; \Sigma \vdash [\iota \mapsto r]\mu
}

\inferrule[\textsc{WF-Env3}] {
  \Delta ; \Sigma \vdash \mu
} {
  \Delta ; [\iota \mapsto \texttt{Future}[T]]\Sigma \vdash [\iota \mapsto v]\mu
}

\inferrule[\textsc{WF-Q1}] {} {
  \Delta ; \Sigma \vdash \epsilon
}

\inferrule[\textsc{WF-Q2}] {
  \Delta(\omega) = T                  \quad
  \Sigma(\iota)  = \texttt{Future}[T] \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\ReqF \iota \omega} :: Q
}

\inferrule[\textsc{WF-Q3}] {
  \Delta(\omega) = T                  \quad
  \emptyset ; \emptyset \vdash v : T
} {
  \Delta ; \Sigma \vdash {\Res \omega v P} :: Q
}

\inferrule[\textsc{WF-Q4}] {
  \Delta(id(r)) = \Delta(\omega) \quad
  \Delta ; \Sigma \vdash Q
} {
  \Delta ; \Sigma \vdash {\Req h r \omega} :: Q
}

\inferrule[\textsc{WF-HostConfig}] {
  \Sigma \vdash \mu              \quad
  \Delta \vdash S                \quad
  \Delta ; \Sigma \vdash \mu     \quad
  \Delta ; \Sigma \vdash Q       \quad
  \Gamma ; \Sigma \vdash t : T
} {
  \Delta ; \Sigma \vdash (t, \mu, Q, S)^h
}

\inferrule[\textsc{WF-Host1}] {} { 
  \vdash \emptyset
}

\inferrule[\textsc{WF-Host2}] {
  \Delta ; \Sigma \vdash (t, \mu, Q, S)^h  \quad
  \vdash H
} {
  \Delta \vdash \{ (t, \mu, Q, S)^h \} \cup H
}

\end{mathpar}
\caption{Well-formedness.}
\end{figure}


\begin{thm}
\emph{(Substitution Lemma)}\label{th:subst}
If $\Gamma , x : T' ; \Sigma \vdash t : T$ and $\Gamma ; \Sigma \vdash v : T'$ then $\Gamma ; \Sigma \vdash [x \mapsto v]t : T$.
\end{thm}
\begin{proof}
By induction on the derivation of $\Gamma , x : T' ; \Sigma \vdash t : T$.
\end{proof}


\begin{thm}
\emph{(Subject Reduction)}\label{th:pres}

\begin{enumerate}

\item If $\Gamma ; \Sigma \vdash t : T$, $\Sigma \vdash \mu$, $\Delta ; \Sigma \vdash \mu$, and $t~|~\mu \rightarrow^h t'~|~\mu'$ then $\Gamma ; \Sigma' \vdash t' : T$, $\Sigma' \vdash \mu'$, and $\Delta' ; \Sigma' \vdash \mu'$ for some $\Sigma' \supseteq \Sigma$ and $\Delta' \supseteq \Delta$.

\item If $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$ and $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$ then $\Delta' ; \Sigma' \vdash (t', \mu', Q', S')^h$ for some $\Delta' \supseteq \Delta$ and $\Sigma' \supseteq \Sigma$.

\item If $\vdash H$ and $H \twoheadrightarrow H'$ then $\vdash H'$.

\end{enumerate}

\end{thm}
\begin{proof}

Part 1: by induction on a derivation of $t~|~\mu \rightarrow^h t'~|~\mu'$ with case analysis of the last applied rule.

\begin{itemize}
\item Case R-AppAbs.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash t : T$
  \item $\Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash \mu$ 
  \item $t~|~\mu \rightarrow^h t'~|~\mu'$
  \end{enumerate}
% 2.
\item By R-AppAbs
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[((x : T') \Rightarrow t'')~v']$
  \item $t' = E[[x \mapsto v']t'']$
  \item $\mu' = \mu$
  \end{enumerate}
% 3.
\item By 1.a) and 2.a), $\Gamma ; \Sigma \vdash ((x : T') \Rightarrow t'')~v' : T''$.
% 4.
\item By 3. and T-App,
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash ((x : T') \Rightarrow t'') : T' \Rightarrow T''$
  \item $\Gamma ; \Sigma \vdash v' : T'$
  \end{enumerate}
% 5.
\item By 4.a) and T-Abs, $\Gamma , x : T' ; \Sigma \vdash t'' : T''$.
% 6.
\item By 4.b), 5., and Lemma~\ref{th:subst}, $\Gamma ; \Sigma \vdash [x \mapsto v']t'' : T''$.
% 7.
\item By 1.a), 2.a-b), 3., and 6., $\Gamma ; \Sigma \vdash t' : T$.
% 8.
\item 1.c), 2.c) and 7. close this case.
\end{enumerate}

\item Cases R-ProjRcd, R-AppSpore, and R-Await follow analogously.

\item Case R-Map.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash t : T$
  \item $\Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash \mu$ 
  \item $t~|~\mu \rightarrow^h t'~|~\mu'$
  \end{enumerate}
% 2.
\item By R-Map
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{map}(\iota, p)]$
  \item $t' = E[\iota']$
  \item $\mu(\iota) = r$
  \item $r' = \text{Mapped}((h, i), r, p, \text{None})$
  \item $i~\text{fresh}$
  \item $\mu' = [\iota' \mapsto r']\mu$
  \item $\iota'~\text{fresh}$
  \end{enumerate}
% 3.
\item By 1.a) and 2.a), $\Gamma ; \Sigma \vdash \texttt{map}(\iota, p) : \hat{T}$.
% 4.
\item By 3. and T-Map,
  \begin{enumerate}[label=(\alph*)]
  \item $\hat{T} = \texttt{SiloRef}[T']$
  \item $\Gamma ; \Sigma \vdash \iota : \texttt{SiloRef}[T'']$
  \item $\Gamma ; \Sigma \vdash p : (T'' \Rightarrow T' \{~\texttt{type}~\mathcal{C} = \seq{T}~\})$
  \end{enumerate}
% 5.
\item Define $\Sigma' := [\iota' \mapsto \texttt{SiloRef}[T']]\Sigma$.
% 6.
\item By 1.b), 2.f), 5., and WF-Store2, $\Sigma' \vdash \mu'$.
% 7.
\item By 5. and T-Loc, $\Gamma ; \Sigma' \vdash \iota' : \texttt{SiloRef}[T']$.
% 8.
\item By 2.g), 3., 4.a), and 5., $\Gamma ; \Sigma' \vdash \texttt{map}(\iota, p) : \texttt{SiloRef}[T']$.
% 9.
\item By 1.a), 2.g) and 5., $\Gamma ; \Sigma' \vdash t : T$
% 10.
\item By 2.a-b), 7., 8., and 9., $\Gamma ; \Sigma' \vdash t' : T$
% 11.
\item By 2.g) and 5., $\Sigma' \supset \Sigma$.
% 12.
\item Define $\Delta' := [id(r') \mapsto T']\Delta$.
% 13.
\item By 1.c), 2.e,g), WF-Env2, $\Delta' ; \Sigma' \vdash \mu$.
% 14.
% 2.f): \mu'     = [\iota' \mapsto r']\mu
% 5.  : \Sigma' := [\iota' \mapsto \texttt{SiloRef}[T']]\Sigma
% 12. : \Delta'  = [id(r') \mapsto T']\Delta
% 13. : \Delta' ; \Sigma' \vdash \mu
\item By 2.f), 5., 12., 13., and WF-Env2, $\Delta' ; \Sigma' \vdash \mu'$.
% 15.
\item 10., 11., and 14. close this case.
\end{enumerate}

\item Cases R-FMap, R-Persist, and R-Unpersist follow analogously.
\end{itemize}

Part 2: by induction on a derivation of $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$ with case analysis of the last applied rule.

\begin{itemize}

\item Case R-Seq. Then $t = E[s]$.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 3.
\item By R-Seq
  \begin{enumerate}[label=(\alph*)]
  \item $E[s]~|~\mu \rightarrow^h E[s']~|~\mu'$
  \item $Q' = Q$
  \item $S' = S$
  \item $t' = E[s']$
  \end{enumerate}
% 4.
\item By 2.e), 2.c), 3.a), and part 1
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma' \vdash E[s'] : T$
  \item $\Sigma' \vdash \mu'$
  \item $\Delta ; \Sigma' \vdash \mu'$
  \item $\Sigma' \supseteq \Sigma$
  \end{enumerate}
% 5.
\item By 2.d), 4.d), and WF-Q1-4, $\Delta ; \Sigma' \vdash Q$.
% 6.
\item By 4.b-c), 3.c), 2.b), 4.a), 5., and WF-HostConfig, $\Delta ; \Sigma' \vdash (E[s'], \mu', Q, S)^h$.
% 7.
\item 3.d), 4.d), and 6. close this case.
\end{enumerate}

\item Case R-Send1Local.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-Send1Local
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{send}(\iota)]$
  \item $t' = E[\iota']$
  \item $Q' = Q$
  \item $S' = S$
  \item $\mu(\iota) = r$
  \item $host(r) = h$
  \item $S(id(r)) = \text{Some}({\Val v}, P)$
  \item $\iota'~\text{fresh}$
  \item $\mu' = [\iota' \mapsto \text{Some}(v)]\mu$  % 2.i)
  \end{enumerate}
% 3.
\item By 1.a), 2.g), and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Gamma ; \Sigma \vdash t : T$
  \item $\Delta(id(r)) = \hat{T}$
  \item $\Delta ; \Sigma \vdash Q$
  \end{enumerate}
% 4.
\item Define $\Sigma' := [\iota' \mapsto \texttt{Future}[\hat{T}]]\Sigma$.
% 5.
\item By 2.i), 3.a), 4., and WF-Store2, $\Sigma' \vdash \mu'$.
% 6.
\item By 2.a), 3.d), and T-Send
  \begin{enumerate}[label=(\alph*)]
  \item $\Gamma ; \Sigma \vdash \texttt{send}(\iota) : \texttt{Future}[T']$
  \item $\Gamma ; \Sigma \vdash \iota : \texttt{SiloRef}[T']$
  \end{enumerate}
% 7.
\item By 6.b) and T-Loc, $\Sigma(\iota) = \texttt{SiloRef}[T']$.
% 8.
\item By 3.c), 3.e), 7., and WF-Env2, $\hat{T} = T'$.
% 9.
\item By 4., 8., and T-Loc, $\Gamma ; \Sigma' \vdash \iota' : \texttt{Future}[T']$.
% 10.
\item By 2.a), 2.b), 3.d), 6.a), and 9., $\Gamma ; \Sigma' \vdash t' : T$.
% 11.
\item By 2.i), 3.c), 4., and WF-Env3, $\Delta ; \Sigma' \vdash \mu'$.
% 12.
\item By 2.h), 3.f), and 4., $\Delta ; \Sigma' \vdash Q$.
% 13.
\item By 2.c-d), 3.b), 5., 10., 11., 12., and WF-HostConfig, $\Delta ; \Sigma' \vdash (t', \mu', Q', S')^h$.
% 14.
\item By 2.h) and 4., $\Sigma' \supset \Sigma$.
% 15.
\item 13. and 14. close this case.
\end{enumerate}

\item Case R-Send2Local follows analogously.

%\inferrule[\textsc{R-ReqF1}] {
%  Q         = {\ReqF \iota \omega} :: Q' \quad
%  S(\omega) = \text{Some}(\Val{v}, P)    \\
%  S'        = {\consume \omega P S}      \quad
%  \mu'      = [\iota \mapsto \text{Some}(v)]\mu
%} {
%  (E[\texttt{await}(\iota')], \mu, Q, S)^h
%  \longrightarrow
%  (E[\texttt{await}(\iota')], \mu', Q', S')^h
%}

\item Case R-ReqF1.
\begin{enumerate}
% 1.
\item By the assumptions
  \begin{enumerate}[label=(\alph*)]
  \item $\Delta ; \Sigma \vdash (t, \mu, Q, S)^h$
  \item $(t, \mu, Q, S)^h \longrightarrow (t', \mu', Q', S')^h$
  \end{enumerate}
% 2.
\item By R-ReqF1
  \begin{enumerate}[label=(\alph*)]
  \item $t = E[\texttt{await}(\iota')]$
  \item $t' = E[\texttt{await}(\iota')]$
  \item $Q = {\ReqF \iota \omega} :: Q'$
  \item $S(\omega) = \text{Some}(\Val{v}, P)$
  \item $S' = {\consume \omega P S}$
  \item $\mu' = [\iota \mapsto \text{Some}(v)]\mu$
  \end{enumerate}
% 3.
\item By 1.a) and WF-HostConfig
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma \vdash \mu$
  \item $\Delta \vdash S$
  \item $\Delta ; \Sigma \vdash \mu$
  \item $\Delta ; \Sigma \vdash Q$
  \item $\Gamma ; \Sigma \vdash t : T$
  \end{enumerate}
% 4.
\item By 2.d), 3.b), and WF-SiloStore2, $\Delta(\omega) = \hat{T}$.
% 5.
\item By 2.c), 3.d), and WF-Q2,
  \begin{enumerate}[label=(\alph*)]
  \item $\Sigma(\iota) = \texttt{Future}[\hat{T}]$
  \item $\Delta ; \Sigma \vdash Q$
  \end{enumerate}
% 6.
\item By 2.f), 3.a), 5.a), and WF-Store2, $\Sigma \vdash \mu'$.
% 7.
\item By 2.d-e), 3.b), WF-SiloStore2, and def. $consume$, $\Delta \vdash S'$.
% 8.
\item By 2.f), 3.c), 5.a), and WF-Env3, $\Delta ; \Sigma \vdash \mu'$.
% 10.
\item By 2.a-b) and 3.e), $\Gamma ; \Sigma \vdash t' : T$.
% 11.
\item By 3.d) and WF-Q2, $\Delta ; \Sigma \vdash Q'$.
% 12.
\item By 6., 7., 8., 10., 11., and WF-HostConfig, $\Delta ; \Sigma \vdash (t', \mu', Q', S')^h$.
% 13.
\item 12. closes this case.
\end{enumerate}

\item Case R-ReqF2 follows analogously.

\end{itemize}

\end{proof}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fault handling.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering
\begin{mathpar}

\inferrule[\textsc{RF-Send}] { 
  host(r) = h'      \quad
  h' \neq h         \quad
  \text{failed}(h') \\
  i~\text{fresh}    \quad
  \iota = (h, i)    \quad
  S'' = S + (\iota \mapsto \bot)
} { 
  \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \twoheadrightarrow
  \{ (R[\iota], E, S'')^h \} \cup H
}

\inferrule[\textsc{RF-Req4}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
}
{ 
  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
}

\inferrule[\textsc{RF-Req5}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
}
{ 
  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
}

\inferrule[\textsc{RF-ReqF}]
{ 
  E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
}
{ 
  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
}

\end{mathpar}
\caption{Fault handling.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{RF-Send}] ...

\item[\textsc{RF-Req4}] XXX Why $4$?

\item[\textsc{RF-Req5}] ...

\item[\textsc{R-ReqF}] ...
\end{description}

\end{document}
