\documentclass{article}
\usepackage{todonotes}
\usepackage{lscape}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{bcprules}
\usepackage{mathpartir}
\usepackage{mdframed}

%% Math
\theoremstyle{definition}
\newtheorem{defn}{Definition}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{defn}{Definition}[section]

%\theoremstyle{definition}
%\newmdtheoremenv[hidealllines=true,topline=true,bottomline=true,skipabove=\baselineskip,skipbelow=\baselineskip]{prop}{Property}[section]

%% Spacing
\newcommand{\gap}{\quad\quad}

%% Arrays
\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

%% Syntax
% Member sequences
\newcommand{\seq}[1]{\overline{#1}}

\newcommand{\note}[1]{{\bf $\clubsuit$ #1 $\spadesuit$}}

%% Calculus abbreviations
\newcommand{\None}{\text{None}}
\newcommand{\Some}[1]{\text{Some}(#1)}
\newcommand{\Val}[1]{\text{Val}(#1)}
\newcommand{\Fwd}[1]{\text{Fwd}(#1)}
\newcommand{\Req}[3]{\text{Req}_s(#1, #2, #3)}
\newcommand{\Res}[3]{\text{Res}_s(#1, #2, #3)}
\newcommand{\ReqF}[3]{\text{Req}_{\iota}(#1, #2, #3)}
\newcommand{\ResF}[2]{\text{Res}_{\iota}(#1, #2)}
\newcommand{\ReqE}[3]{\text{Req}_f(#1, #2, #3)}
\newcommand{\Per}[3]{\text{Persist}(#1, #2, #3)}
\newcommand{\consume}[3]{\text{consume}(#1, #2, #3)}

\begin{document}

\todo[inline]{Turn into a typed calculus}
\todo[inline]{Fix fault tolerance}
\todo[inline]{Fix memory handling\\[2ex] IDEA: provide explicit operators for memory handling; a subsequent static analysis would augment those explicit declaration with further usage of those explicit operators; i.e., a static analysis yields a composition of those memory handling primitives\\[2ex] First approach: incorporate reference counting}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Core language abstract syntax.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
t ::=                                                                       & \mbox{{\it{terms:}}} \\                                
\gap \:\:\:\:  x                                                            & \mbox{variable} \\                                
\gap ~|~  (x: T) \Rightarrow t                                              & \mbox{abstraction} \\                                
\gap ~|~  t~t                                                               & \mbox{application} \\                                
%\gap ~|~  \texttt{let}~x = t~\texttt{in}~t                                  & \mbox{let binding} \\                                
\gap ~|~  \{ \seq{l = t} \}                                                 & \mbox{record construction} \\                                
\gap ~|~  t.l                                                               & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}       & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(t)                                                 & \mbox{spawn host} \\
\gap ~|~  \texttt{populate}(t, t)                                           & \mbox{populate silo} \\
\gap ~|~  \texttt{map}(t, t[, t])                                           & \mbox{map} \\                          
\gap ~|~  \texttt{flatMap}(t, t[, t])                                       & \mbox{flatMap} \\                          
\gap ~|~  \texttt{persist}(t)                                               & \mbox{persist} \\
\gap ~|~  \texttt{send}(t)                                                  & \mbox{send} \\           % send  :: Ref a -> Fut a
\gap ~|~  \texttt{await}(t)                                                 & \mbox{await future} \\   % await :: Fut a -> a                        
\gap ~|~  \iota                                                                 & \mbox{location} \\                          
                                                                            & \\                                
v ::=                                                                       & \mbox{{\it{values:}}} \\                                
\gap \:\:\:\: (x: T) \Rightarrow t                                          & \mbox{abstraction value} \\                                
\gap ~|~  \{ \seq{l = v} \}                                                 & \mbox{record value} \\                                
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\}                                                                 & \mbox{spore value} \\                                
\gap ~|~  \iota                                                             & \mbox{location} \\
                                                                            & \\   
T ::=                                                                       & \mbox{{\it{types:}}} \\                          
\gap \:\:\:\: T \Rightarrow T                                               & \mbox{function type} \\                          
\gap ~|~  \{ \seq{l : T} \}                                                 & \mbox{record type} \\                          
\gap ~|~  \mathcal{S}                                                       & \mbox{} \\
\gap ~|~  \texttt{Host}                                                     & \mbox{host type} \\
\gap ~|~  \texttt{SiloRef}[T]                                               & \mbox{silo reference type} \\
\gap ~|~  \texttt{Future}[T]                                                & \mbox{future type} \\
\mathcal{S} ::= T \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}   & \mbox{spore type} \\
\gap ~|~ T \Rightarrow T~\{~\texttt{type}~\mathcal{C}~\}                    & \mbox{abstract spore type} \\
\ea$

\caption{Abstract syntax of core language.}
\end{figure}

Classification of $r$ and $\iota$ is specified at Figure~\ref{fig:elems-opsem}.

$\iota$ .... decentralized identifier

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Elements of the operational model.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

$\ba[t]{l@{\hspace{2mm}}l}
r ::=                                                  & \mbox{{\it{silo reference values:}}} \\
\gap \:\:\:\: \text{Mat}(\omega)                       & \mbox{materialized} \\    
\gap ~|~  \text{Mapped}(\omega, r, p, opt_f)           & \mbox{lineage with \texttt{map}} \\    
\gap ~|~  \text{FMapped}(\omega, r, p, opt_f)          & \mbox{lineage with \texttt{flatMap}} \\   
\gap ~|~  \text{Persist}(\omega, r)                    & \mbox{lineage with \texttt{persist}} \\
                                                       & \\   
\omega  ::= (h,i) \quad \text{where}~i \in \mathbb{N}  & \mbox{decentralized identifier} \\
                                                       & \\
Q      ::=                                             & \mbox{{\it{message queue values:}}} \\
\gap \:\:\:\: \epsilon                                 & \mbox{empty queue} \\
\gap ~|~    {\Res \omega v P} :: Q                     & \mbox{response (silo)} \\
\gap ~|~    {\Req h r \omega} :: Q                     & \mbox{request (silo)}  \\
\gap ~|~    {\ResF \iota v P} :: Q                     & \mbox{response (future)} \\
\gap ~|~    {\ReqF h r \iota} :: Q                     & \mbox{request (future)}  \\
\gap ~|~    {\ReqE h r \omega} :: Q                    & \mbox{request (fault)} \\
\ea$

\caption{Elements of the operational model.}
\label{fig:elems-opsem}

\end{figure}

\begin{description}
%\item[$\iota$] Encodes latency, in terms of completion of a materialization of a silo, as well as the location of the either already materialized or to be materialized silo. The location, in turn, serves as the unique, decentralized identifier of the respective silo reference.

% << Network communication >>
%
%               <<CODE>>                                                    << LINEAGE>>                             <<SILO>>
% Host: h0    
% val r0: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))                   ~~>        h1 
% r0.id    == (h1,0)                                                              ^
% host(r0) == h1                                                                  |
%                                                                                 |
% << No network communication >>                                                  |
%                                                                                 |
% val r1: SiloRef[List[Vehicle]] = r0 map sp0                           ~~>   Mapped((h0,0), r0, sp0, None) ~~>        h1
% r1.id    == (h0,0)      
% host(r1) == h1      
%   
% << Network communication >>   
%   
% val r2: SiloRef[List[Vehicle]] = Silo.fromTextFile(h1)("hdfs://foo")  ~~>   Mat((h1,0))
% r2.id    == (h1,0)
% host(r2) == h1 
% r2       == r0

\item[$Mat(\iota)$] A silo reference where the referenced silo is already materialized, or is to be materialized, at location $\iota$.
% (h,i) is the decentralized identifier of the materialized silo hosted at h. In this case \iota gives us the location of the materialized silo.

\item[$Mapped(\iota, r, p, opt_f)$] Map spore $p$ over the silo which is referenced by $r$. The resulting silo of this transformation is referenced by the new silo reference identified by $\iota$. In case of failure at the host of the referenced silo apply $opt_f$.  

%      r     --> s  @ host(r)
%                ^
%                |
%                | Mapped
%                |
%      r'    --> s' @ host(r) = host(r')
%
% Decentralized identifier of r' is \iota.

\item[$FMapped(\iota, r, p, opt_f)$] Analogous to $Mapped$.
\end{description}

A lineage build up by those silo reference values can be considered as a {\emph{data flow graph}}\cite{???}. %Note, verbalisation is imperative to emphasize lazy creation. 

\begin{description}
\item[${\Res \iota v P}$] A response message which instructs the receiver to complete future $\iota$ with value $v$. % TODO: explain `P`.

\item[${\Req h r \iota}$] A request message from $h$ which instructs the receiver to respond with the materialized silo referenced by $r$; $\iota$ uniquely identifies the response in terms of the future $\iota$ to be completed by the sender of the request.

\item[$ReqF(h, r, \iota)$] Analogous to $Req$.
\end{description}

In the following we introduce a function to backtrack the host of a referenced silo.

\begin{defn}[Host]
  The function application $host(r)$ obtains the host of the silo referenced by $r$; $host$ is defined as follows:
  
  $host(r) := \begin{cases}
    h        & \text{if } r = Mat((h, i)) \\
    host(r') & \text{if } r = Mapped(\_, r', \_, \_) \\
    host(r') & \text{if } r = FMapped(\_, r', \_, \_) \\
    host(r') & \text{if } r = Persist(\_, r', \_) \\
    \end{cases}$
\end{defn}

Analogous to~\cite{TAPL}, we introduce the notion of an evaluation context and write $E[t]$ for the ordinary term obtained by replacing the hole in $E$ with $t$. Evaluation contexts capture the notion of the ``next subterm to be reduced.''

\begin{defn}[Evaluation Context]
  The set of evaluation contexts is defined as follows:
  
 $\ba[t]{l@{\hspace{2mm}}l}
E ::=                                                                                                     & \mbox{\it{evaluation contexts:}} \\
\gap \:\:\:\: [~]                                                                                         & \mbox{hole} \\
\gap ~|~  E~t                                                                                             & \mbox{application (fun)} \\
\gap ~|~  v~E                                                                                             & \mbox{application (arg)} \\
%\gap ~|~  \texttt{let}~x = E~\texttt{in}~t                                                                & \mbox{let (bind)} \\
%\gap ~|~  \texttt{let}~x = v~\texttt{in}~E                                                                & \mbox{let (body)} \\
\gap ~|~  \{ \seq{l = v} ; l_i = E ; \seq{l' = t} \}                                                      & \mbox{record} \\
\gap ~|~  E.l                                                                                             & \mbox{selection} \\
\gap ~|~  \texttt{spore}~\{~\seq{x : T = v} ; x_i : T_i = E ; \seq{x' : T = t} ; (x: T) \Rightarrow t~\}  & \mbox{spore} \\
\gap ~|~  \texttt{spawn}(E)                                                                               & \mbox{spawn} \\
\gap ~|~  \texttt{populate}(E, t)                                                                         & \mbox{populate (host)} \\
\gap ~|~  \texttt{populate}(v, E)                                                                         & \mbox{populate (spore)} \\
\gap ~|~  \texttt{map}(E, t[, t])                                                                         & \mbox{map (ref)} \\
\gap ~|~  \texttt{map}(v, E[, t])                                                                         & \mbox{map (fun)} \\
\gap ~|~  \texttt{map}(v, v', E)                                                                          & \mbox{map (err)} \\
\gap ~|~  \texttt{flatMap}(E, t[, t])                                                                     & \mbox{flatMap (ref)} \\
\gap ~|~  \texttt{flatMap}(v, E[, t])                                                                     & \mbox{flatMap (fun)} \\
\gap ~|~  \texttt{flatMap}(v, v', E)                                                                      & \mbox{flatMap (err)} \\
\gap ~|~  \texttt{persist}(E)                                                                             & \mbox{persist} \\
\gap ~|~  \texttt{send}(E)                                                                                & \mbox{send} \\
\gap ~|~  \texttt{await}(E)                                                                               & \mbox{await} \\
\ea$ 
\end{defn}

\begin{defn}[Silo reference identifier]
    $id(r) := \begin{cases}
    \omega  & \text{if } r = Mat(\omega) \\
    \omega  & \text{if } r = Mapped(\omega, r', \_, \_) \\
    \omega  & \text{if } r = FMapped(\omega, r', \_, \_) \\
    \omega  & \text{if } r = Persist(\omega, r', \_) \\
    \end{cases}$
\end{defn}

\begin{defn}[Silo reference parent]
    $parent(r) := \begin{cases}
    \None     & \text{if } r = Mat(\_) \\
    \Some{r'} & \text{if } r = Mapped(\_, r', \_, \_) \\
    \Some{r'} & \text{if } r = FMapped(\_, r', \_, \_) \\
    \Some{r'} & \text{if } r = Persist(\_, r', \_) \\
    \end{cases}$
\end{defn}

\begin{defn}[Consume silo]
Consume silo $\omega$ with persist set $P$ in silo store $S$ \\
  $consume(\omega, P, S) := \begin{cases}
  S - \omega & \text{if } P = \emptyset \\
  S          & \text{otherwise} \\
  \end{cases}$
\end{defn}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Lambda reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-AppAbs}] {} {
  E[((x: T) \Rightarrow t)~v']~|~\mu
  \rightarrow^h
  E[[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-ProjRcd}] {} {
  E[\{\seq{l_i = v_i^{i \in 1..n}}\}.l_j]~|~\mu
  \rightarrow^h
  E[v_j]~|~\mu
}

\inferrule[\textsc{R-AppSpore}] {} {
  E[(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~v']~|~\mu
  \rightarrow^h
  E[\seq{[x \mapsto v]}[x \mapsto v']t]~|~\mu
}

\inferrule[\textsc{R-Map}] { 
  r' = \text{Mapped}((h, i), r, p, \text{None}) \quad
  i~\text{fresh} \quad
  \mu' = \mu + (\iota \mapsto r') \quad \iota~\text{fresh}
} { 
  E[\texttt{map}(r, p)]~|~\mu
  \rightarrow^h
  E[\iota]~|~\mu'
}

\inferrule[\textsc{R-FMap}] { 
  r' = \text{FMapped}((h, i), r, p, \text{None}) \quad
  i~\text{fresh} \quad
  \mu' = \mu + (\iota \mapsto r') \quad \iota~\text{fresh}
} {
  E[\texttt{flatMap}(r, p)]~|~\mu
  \rightarrow^h
  E[\iota]~|~\mu'
}

\inferrule[\textsc{R-Persist}] { 
  r' = \text{Persist}((h, i), r, \cdot \cup \cdot) \quad
  i~\text{fresh} \quad
  \mu' = \mu + (\iota \mapsto r') \quad \iota~\text{fresh}
} { 
  E[\texttt{persist}(r)]~|~\mu
  \rightarrow^h
  E[\iota]~|~\mu'
}

\inferrule[\textsc{R-Unpersist}] { 
  r' = \text{Persist}((h, i), r, \cdot \setminus \cdot) \quad
  i~\text{fresh} \quad
  \mu' = \mu + (\iota \mapsto r') \quad \iota~\text{fresh}
} { 
  E[\texttt{unpersist}(r)]~|~\mu
  \rightarrow^h
  E[\iota]~|~\mu'
}

\end{mathpar}
\caption{Sequential reduction.}
\end{figure}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Define silo store

We write $S' = S + (\iota \mapsto (B, P))$ to express the fact that $S'$ maps $\iota$ to a pair $(B, P)$ and otherwise agrees with $S$. $B$ is a binding of the form $\Val{v}$ or $\Fwd{r}$; the former contains a materialized value $v$, the latter forwards to silo reference $r$, such that $\iota$ is effectively bound to the same value as the identifier of $r$. $P \subset Hosts$ is a set of hosts which have persisted the silo identified by $\iota$. We write $S(\iota) = \text{Some}(B, P)$ to express the fact that $S$ maps $\iota$ to $(B, P)$. We write $S(\iota) = \text{None}$ if $S$ does not have a mapping for $\iota$.

Our formalization simplifies the computation model with respect to materialized silos. In case of a silo reference of the form $Mat((h, i))$ we assume that there is a mapping in the corresponding silo store $S$, such that $S((h, i)) = \text{Some}(\Val{v}, \{ h \})$ for some value $v$.

%% r = Mat((h,i)) = init(hdfs://...)
%% r.unpersist

\begin{figure}[ht!]
\centering

\begin{mathpar}
\inferrule[\textsc{R-Seq}] { 
  E[t]~|~\mu \rightarrow^h E[t']~|~\mu'
} {
  (E[t], \mu, Q, S)^h
  \longrightarrow
  (E[t'], \mu', Q, S)^h
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\inferrule[\textsc{R-SendLocal}] {
  \mu(\iota) = r                         \quad
  host(r) = h                            \quad
  \iota'~\text{fresh}                    \quad
  \mu' = [\iota' \mapsto \text{None}]\mu
} {
  (E[\texttt{send}(\iota)], \mu, Q, S)^h
  \rightarrow
  (E[\iota'], \mu', Q \cdot {\ReqF h r \iota'}, S)^h
}

\inferrule[\textsc{R-Await}] {
  \mu(\iota) = \text{Some}(v)
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[v], \mu, Q, S)^h
}

\inferrule[\textsc{R-ReqF1}] {
  Q        = {\ReqF h r \iota} :: Q'    \quad
  S(id(r)) = \text{Some}(\Val{v}, P)    \quad
  S'       = {\consume {id(r)} P S}
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu, Q' \cdot {\ResF \iota v}, S')^h
}

\inferrule[\textsc{R-ReqF2}] {
  Q        = {\ReqF h r \iota} :: Q'    \quad
  S(id(r)) \neq \text{Some}(\Val{v}, P)
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu, Q' \cdot {\Req h r {id(r)}} \cdot {\ReqF h r \iota}, S')^h
}

\inferrule[\textsc{R-ResF}] {
  Q  = {\ResF \iota v} :: Q'          \\
  \mu' = [\iota \mapsto \text{Some}(v)]\mu
} {
  (E[\texttt{await}(\iota')], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota')], \mu', Q', S)^h
}

\end{mathpar}
\caption{Deterministic reduction (future).}
\end{figure}

% Note: design approach is to *not* replace Fwds in the silo store, since
% it would require copying data. Instead, we leverage the flexibility of
% Req messages to correctly forward requests.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Important that Res message contains correct P, since R-Res
% updates silo store.
% Goal: theorem which states that persist sets are "correct".
% We don't lose hosts from persist sets.

\begin{figure}[ht!]
\centering

\begin{mathpar}

\inferrule[\textsc{R-Res}] {
  Q  = {\Res \omega v P} :: Q'          \\
  S' = S + (\omega \mapsto (\Val{v}, P))
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \longrightarrow
  (E[\texttt{await}(\iota)], \mu, Q', S')^h
}

\inferrule[\textsc{R-Req1Local}] {
  Q         = {\Req h r \omega} :: Q'        \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)       \quad %
  S(id(r')) = \text{Some}(\Val{v}, P')       \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \rightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v P}, S')^h
}

\inferrule[\textsc{R-Req2Local}] {
  Q         = {\Req h r \omega} :: Q'              \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)             \quad %
  S(id(r')) \neq \text{Some}(\Val{v}, P')          \quad %
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \rightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} \omega}, S')^h
}

\inferrule[\textsc{R-ReqMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'                    \quad %
  r          = \text{Mapped}(\omega', r', p, \text{None})    \quad %
  S(id(r'))  = \text{Some}(\Val{v}, P)                       \\
  v'         = p(v)                                          \quad %
  S'         = S  + (\omega' \mapsto (\Val{v'}, \emptyset))  \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \rightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} r \omega}, S'')^h
}

\inferrule[\textsc{R-ReqFMapLocal}] {
  Q          = {\Req {h'} r \omega} :: Q'                   \quad %
  r          = \text{FMapped}(\omega', r', p, \text{None})  \quad %
  S(id(r'))  = \text{Some}(\Val{v}, P)                     \\
  r''        = p(v)                                        \quad %
  S'         = S + (\omega' \mapsto (\Fwd{r''}, \emptyset)) \quad
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \rightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req {h'} {r''} \omega}, S'')^h
}

\inferrule[\textsc{R-ReqPersistLocal}] {
  Q          = {\Req h r \omega} :: Q'                      \quad %
  r          = {\Per {\omega'} {r'} \star}                  \quad %
  \omega'    = (h, i)                                      \quad %
  S(id(r'))  = \text{Some}(\Val{v}, P)                     \\
  P'         = P \star \{h\}                               \quad %
  S'         = S  + (\omega' \mapsto (\Val{v}, P'))         \quad %
  S''        = {\consume {id(r')} P {S'}}
} {
  (E[\texttt{await}(\iota)], \mu, Q,  S)^h
  \rightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Res \omega v {P'}}, S'')^h
}

\inferrule[\textsc{R-ReqParentLocal}] {
  Q               = {\Req {h'} r \omega} :: Q'  \quad %
  \text{Some}(r') = parent(r)                  \quad %
  S(id(r'))     \neq \text{Some}(\Val{v}, P)   \\
} {
  (E[\texttt{await}(\iota)], \mu, Q, S)^h
  \rightarrow
  (E[\texttt{await}(\iota)], \mu, Q' \cdot {\Req h {r'} {id(r')}} \cdot {\Req {h'} r \omega}, S)^h
}

\end{mathpar}
\caption{Deterministic reduction (silo).}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Map}] ...

\item[\textsc{R-FMap}] ...

\item[\textsc{R-Await}] ...

\item[\textsc{R-Res}] ...

\item[\textsc{R-ReqLocal}] ...
\end{description}

Note, the reduction rules \textsc{R-Map} and \textsc{R-FMap} do not involve communication with other hosts.

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Non-deterministic reduction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% (t, Q, S)^h_c -> <crash>
% H' = { h' | h \in H \land h' = crashed(h_c, h) }
% --------------------------------------------------
%    { (t, Q, S)^h_c } \cup H -->> H'
%
%
% update silo store to reflect crash of h_c
% S' = { id -> (v, C') | id -> (v, C) \in S \land C' = C[h_c -> 0] }
% ---------------------------------------------------------------------
%    crashed(h_c, (t, Q, S)^h) = (t, Q, S')^h
%
%
%   S(id) =  Some(v)       |  None
%
%   S(id) = (Some(v), cnt) | (None, cnt)
%
%   S(id) = (Some(v), [h -> 3, h' -> 2]) | (None, ...)
%
%   S(id) = (Some(v), C)   | (None, C)


\begin{figure}[ht!]
\begin{mathpar}
\inferrule[\textsc{R-Determ}] {
  (t, \mu, Q, S)^h \rightarrow (t', \mu', Q', S')^h
} { 
  \{ (t, \mu, Q, S)^h \} \cup H
  \twoheadrightarrow
  \{ (t', \mu', Q', S')^h \} \cup H
}

\inferrule[\textsc{R-Spawn}] { 
  h'~\text{fresh}
} {
  \{ (E[\texttt{spawn}(\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})], \mu, Q, S)^h \} \cup H
  \\ \twoheadrightarrow
  \{ (E[h'], \mu, Q, S)^h, ((\texttt{spore}~\{~\seq{x : T = v}~; (x: T) \Rightarrow t~\})~\{\}, \epsilon, \epsilon, \epsilon)^{h'} \} \cup H
}

% TODO send spore instead of a value `v`
\inferrule[\textsc{R-Populate}] { 
  S''    = S' + (\omega \mapsto v)      \quad
  \omega = (h', i) \quad i~\text{fresh} \quad
  \mu'' = [\iota \mapsto \text{Mat}(\omega)]\mu \quad \iota~\text{fresh}
} {
  \{ (E[\texttt{populate}(h', v)], \mu, Q, S)^h, (t', \mu', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\iota], \mu'', Q, S)^h, (t', \mu', Q', S'')^{h'} \} \cup H
}

\inferrule[\textsc{R-Req1}] { 
  Q        = {\Req {h'} r \iota} :: Q''  \quad
  S(id(r)) = \text{Some}(\Val{v}, P)     \quad
  m        = {\Res \iota v P}
} { 
  \{ (E[\texttt{await}(\iota')], Q, S)^h, (t', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota')], Q'', S)^h, (t', Q' \cdot m, S')^{h'} \} \cup H
}

% Rules that send Req:
% R-Send: true (append)
% (R-Req2Map: true (prepend))
% R-Req2Fwd: true (prepend)
% 
% if a rule sends Req(h, r) to h', is it true that host(r) == h'?
% XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

\inferrule[\textsc{R-Req2}] {
  Q         = {\Req {h'} r \iota} :: Q''           \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)             \\ %
  S(id(r')) = \text{Some}(\Val{v}, P')             \quad %
  m        = {\Res \iota v P}
} {
  \{ (E[\texttt{await}(\iota')], Q, S)^h, (t', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota')], Q'', S)^h, (t', Q' \cdot m, S')^{h'} \} \cup H
}

% 1. Angenommen Host h hat einen \Fwd{r'}, dann wissen wir nicht, 
%    auf welchem Host r' liegt. Das war der eigentliche Grund, Fwd
%    einzufuehren, weil dann ein flatMap keine Daten transferieren muss.
%    D.h. wir wollen zulassen, dass eine Referenz in einem Fwd auf
%    einem beliebigen Host liegen kann.
% Jetzt kann es sein, dass ich auf Host h ein r = r0.flatMap(p) mache.
% diese Referenz r kann ich an einen anderen Host h' geben.
% Jetzt macht Host h' ein r.send(). D.h., h' schickt einen Req(h', r) an h.
% Jetzt sagt Host h: S(id(r)) = Fwd(r'), und r' kann auch auf Host h' sein
% (da Host von r' beliebig wie oben erwaehnt).
% Und in diesem Fall gilt, dass host(r') = h' ist, und daher Host h
% einen Req(h', r' r) an h'' = h' sendet. Das hat zur Folge, das Host h'
% jetzt einen Req(h', r', r) bearbeiten muss. Daher muessen auch die lokalen
% Regeln mit zwei unterschiedlichen Referenzen umgehen koennen, weil
% r definitiv ungleich r' ist.
\inferrule[\textsc{R-Req3}] {
  Q         = {\Req {h''} r \iota} :: Q''            \quad %
  S(id(r))  = \text{Some}(\Fwd{r'}, P)               \\ %
  S(id(r')) \neq \text{Some}(\Val{v}, P')            \quad %
  h'        = host(r')                               \quad %
  m         = {\Req {h''} {r'} \iota}
} {
  \{ (E[\texttt{await}(\iota')], Q, S)^h, (t', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[\texttt{await}(\iota')], Q'', S)^h, (t', Q' \cdot m, S')^{h'} \} \cup H
}

\inferrule[\textsc{R-Send}] {
  host(r) = h' \quad h' \neq h \quad m = {\Req h r {id(r)}}
} {
  \{ (E[\texttt{send}(r)], Q, S)^h, (t', Q', S')^{h'} \} \cup H
  \twoheadrightarrow
  \{ (E[id(r)], Q, S)^h, (t', Q' \cdot m, S')^{h'} \} \cup H
}

\end{mathpar}
\caption{Non-deterministic reduction.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{R-Send}] ...

\item[\textsc{R-Req1}] ...

\item[\textsc{R-Req2}] ...

\item[\textsc{R-Req3}] ...

\item[\textsc{R-Req4}] ...
\end{description}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Type assignment.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\begin{mathpar}
% variable
\inferrule[\textsc{T-Var}] {
  x : T \in \Gamma
} { 
  \Gamma ; \Sigma \vdash x : T
}

\inferrule[\textsc{T-SiloRef}] {
  \Sigma(r) : T
} {
  \Gamma ; \Sigma \vdash r : \texttt{SiloRef}[T]
}

\inferrule[\textsc{T-Future}] {
  \Sigma(\iota) : T
} {
  \Gamma ; \Sigma \vdash \iota : \texttt{Future}[T]
}

% abstraction
\inferrule[\textsc{T-Abs}] {
  \Gamma, x : T ; \Sigma \vdash t : T'
} { 
  \Gamma ; \Sigma \vdash ((x: T) \Rightarrow t) : T \Rightarrow T'
}

% application
\inferrule[\textsc{T-App}] {
  \Gamma ; \Sigma \vdash t : T \Rightarrow T' \quad \Gamma ; \Sigma \vdash t' : T
} { 
  \Gamma ; \Sigma \vdash (t~t') : T'
}

% record
\inferrule[\textsc{T-Record}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T}
} {
  \Gamma ; \Sigma \vdash \{ \seq{l = t} \} : \{ \seq{l : T} \}
}

% selection
\inferrule[\textsc{T-Select}] {
  \Gamma ; \Sigma \vdash t : \{ \seq{l : T} \}
} {
  \Gamma ; \Sigma \vdash t.l_i : T_i
}

% spore
\inferrule[\textsc{T-Spore}] {
  \Gamma ; \Sigma \vdash \seq{t} : \seq{T} \quad \seq{x : T}, x : T ; \Sigma \vdash t : T'
} { 
  \Gamma ; \Sigma \vdash (\texttt{spore}~\{~\seq{x : T = t}~; (x: T) \Rightarrow t~\}) : T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\}
}

% spawn
\inferrule[\textsc{T-Spawn}] {
  \Gamma ; \Sigma \vdash t : (\{\} \Rightarrow T~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{spawn}(t) : \texttt{Host}
}

% populate
\inferrule[\textsc{T-Populate}] {
  \Gamma ; \Sigma \vdash t : \texttt{Host} \quad \Gamma ; \Sigma \vdash t' : T
} {
  \Gamma ; \Sigma \vdash \texttt{populate}(t, t') : \texttt{SiloRef}[T]
}

% map
\inferrule[\textsc{T-Map}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad \Gamma ; \Sigma \vdash t' : (T \Rightarrow T'~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{map}(t, t') : \texttt{SiloRef}[T']
}

% flatMap
\inferrule[\textsc{T-FMap}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T] \quad \Gamma ; \Sigma \vdash t' : (T \Rightarrow \texttt{SiloRef}[T']~\{~\texttt{type}~\mathcal{C} = \seq{T}~\})
} {
  \Gamma ; \Sigma \vdash \texttt{flatMap}(t, t') : \texttt{SiloRef}[T']
}

% persist
\inferrule[\textsc{T-Persist}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{persist}(t) : \texttt{SiloRef}[T]
}

% send
\inferrule[\textsc{T-Send}] {
  \Gamma ; \Sigma \vdash t : \texttt{SiloRef}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{send}(t) : \texttt{Future}[T]
}

% await
\inferrule[\textsc{T-Await}] {
  \Gamma ; \Sigma \vdash t : \texttt{Future}[T]
} {
  \Gamma ; \Sigma \vdash \texttt{await}(t) : T
}

%         \gap ~|~  \iota                                                             & \mbox{future} \\
%\gap ~|~  h                                                                 & \mbox{host} \\


\end{mathpar}
\caption{Type assignment.}
\end{figure}

\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Fault handling.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[ht!]
\centering
\begin{mathpar}

\inferrule[\textsc{RF-Send}] { 
  host(r) = h'      \quad
  h' \neq h         \quad
  \text{failed}(h') \\
  i~\text{fresh}    \quad
  \iota = (h, i)    \quad
  S'' = S + (\iota \mapsto \bot)
} { 
  \{ (R[\texttt{send}(r)], E, S)^h \} \cup H \twoheadrightarrow
  \{ (R[\iota], E, S'')^h \} \cup H
}

\inferrule[\textsc{RF-Req4}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E'' \quad r = \text{FMapped}(\iota, h, r'', p, \text{Some}(p_f)) \quad S(\iota) = \text{None} \\
  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad p(v) = r' \quad \text{failed}(host(r')) \quad p_f(v) = r_f \quad host(r_f) = h_f \quad \lnot \text{failed}(h_f) \\
  loc(r_f) = \iota_f \quad S(\iota_f) = \text{None} \quad m = \text{Req}(h, r_f, \iota_f) \quad E''' = \text{Req}(h'', r_f, \iota'') \texttt{::} E''
}
{ 
  \{ (R[\texttt{await}(\iota_f)], E, S)^h, (t, E', S')^{h_f} \} \cup H \rightarrow \{ (R[\texttt{await}(\iota_f)], E''', S)^h, (t, E' \cdot m, S')^{h_f} \} \cup H
}

\inferrule[\textsc{RF-Req5}]
{ 
  E = \text{Req}(h'', r, \iota'') \texttt{::} E' \quad r = \text{FMapped}(\iota, h, r'', p, \text{None}) \quad S(\iota) = \text{None} \quad loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \\
  p(v) = r' \quad \text{failed}(host(r')) \quad i_p, i_a~\text{fresh} \quad \iota_p = (h, i_p), \iota_a = (h, i_a) \quad m_p = \text{ReqF}(h, r'', \iota_p) \\
  r_a = \text{FMapped}(\iota_a, h, \text{Mat}(\iota_p), p, \text{None}) \quad E'' = m_p \texttt{::} \text{Req}(h'', r_a, \iota'') \texttt{::} E'
}
{ 
  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
}

\inferrule[\textsc{RF-ReqF}]
{ 
  E = \text{ReqF}(h, r, \iota') \texttt{::} E' \quad r = \text{Mapped}(\iota, h, r'', p, \text{Some}(p_f)) \\
  loc(r'') = \iota_s \quad S(\iota_s) = \text{Some}(v) \quad E'' = \text{Res}(\iota', p_f(v)) \texttt{::} E'
}
{ 
  (R[\texttt{await}(\iota_f)], E, S)^h \longrightarrow (R[\texttt{await}(\iota_f)], E'', S)^h
}

\end{mathpar}
\caption{Fault handling.}
\end{figure}

\begin{description}[font=\normalfont\itshape\space]
\item[\textsc{RF-Send}] ...

\item[\textsc{RF-Req4}] XXX Why $4$?

\item[\textsc{RF-Req5}] ...

\item[\textsc{R-ReqF}] ...
\end{description}

\end{document}
